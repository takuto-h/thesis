%%
% このファイルは、筑波大学情報学群情報科学類の
% 卒業研究論文本体のサンプルです。
% このファイルを書き換えて、この例と同じような書式の論文本体を
% LaTeXを使って作成することができます。
% 
% PC環境や、LaTeX環境の設定によっては漢字コードや改行コードを
% 変更する必要があります。
%%
\documentclass[a4paper,11pt,dvipdfmx]{jreport}

%%【PostScript, JPEG, PNG等の画像の貼り込み】
%% 利用するパッケージを選んでコメントアウトしてください。
\usepackage{graphicx} % for \includegraphics[width=3cm]{sample.eps}
%\usepackage{epsfig} % for \psfig{file=sample.eps,width=3cm}
%\usepackage{epsf} % for \epsfile{file=sample.eps,scale=0.6}
%\usepackage{epsbox} % for \epsfile{file=sample.eps,scale=0.6}

%% dvipdfm を使う場合(dvi->pdfを直接生成する場合)
%\usepackage[dvipdfm]{color,graphicx}
%% dvipdfm を使ってPDFの「しおり」を付ける場合
%\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,bookmarkstype=toc]{hyperref}
%% 参考：dvipdfm 日本語版
%% http://hamilcar.phys.kyushu-u.ac.jp/~hirata/dvipdfm/

\usepackage[bookmarksnumbered=true]{hyperref}
\usepackage{pxjahyper}

\usepackage{times} % use Times Font instead of Computer Modern

\setcounter{tocdepth}{3}
\setcounter{page}{-1}

\setlength{\oddsidemargin}{0.1in}
\setlength{\evensidemargin}{0.1in} 
\setlength{\topmargin}{0in}
\setlength{\textwidth}{6in} 
%\setlength{\textheight}{10.1in}
\setlength{\parskip}{0em}
\setlength{\topsep}{0em}

%\newcommand{\zu}[1]{{\gt \bf 図\ref{#1}}}

%% タイトル生成用パッケージ(重要)
\usepackage{coins-jp}
\usepackage{jumoline}

%% タイトル
%% 【注意】タイトルの最後に\\ を入れるとエラーになります
\title{\Underline{レキシカル環境にメソッドを定義する\\オブジェクト指向言語Suzu}}
%% 著者
\author{林 拓人}
%% 指導教員
\advisor{前田敦司}

%% 専攻名 と 年月 (提出年月)
%% 年月は必要に応じて書き替えてください。
\heiseiyear{26}  % 平成の年度
\majorfield{ソフトウェアサイエンス主専攻}
%\majorfield{情報システム主専攻}
%\majorfield{知能情報メディア主専攻}

\makeatletter%% プリアンブルで定義する場合は必須

%% (j)report・(j)book クラスの場合
%% 
\renewenvironment{thebibliography}[1]% 再定義
{\chapter*{\bibname\@mkboth{\bibname}{\bibname}}%
	\addcontentsline{toc}{chapter}{\numberline{}\bibname}% この行追加
	\list{\@biblabel{\@arabic\c@enumiv}}%
	{\settowidth\labelwidth{\@biblabel{#1}}%
		\leftmargin\labelwidth
		\advance\leftmargin\labelsep
		\@openbib@code
		\usecounter{enumiv}%
		\let\p@enumiv\@empty
		\renewcommand\theenumiv{\@arabic\c@enumiv}}%
	\sloppy
	\clubpenalty4000
	\@clubpenalty\clubpenalty
	\widowpenalty4000%
	\sfcode`\.\@m}
{\def\@noitemerr
	{\@latex@warning{Empty `thebibliography' environment}}%
	\endlist}

\makeatother%% プリアンブルで定義する場合は必須

\usepackage{listings}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage

\thispagestyle{empty}
\vspace*{20pt plus 1fil}
\parindent=1zw
\noindent
%%
%% 論文の概要(Abstract)
%%
\begin{center}
{\Large \bf 要　　旨}
\vspace{2cm}
\end{center}
[400字程度]

%%%%%
\par
\vspace{0pt plus 1fil}
\newpage

\pagenumbering{roman} % I, II, III, IV 
\tableofcontents
%\listoffigures
%\listoftables

\pagebreak \setcounter{page}{1}
\pagenumbering{arabic} % 1,2,3


\chapter{序論}

オブジェクト指向言語とは，オブジェクト指向プログラミングの支援機構を持つプログラミング言語の総称である．
多くのオブジェクト指向言語が持つ概念としてクラスとメソッドが挙げられる．
クラスはオブジェクトの属性，メソッドはオブジェクトに対する操作である．
あるクラスを属性として持つオブジェクトをそのクラスのインスタンスと呼ぶ．
オブジェクトに対しメソッド名を指定してメソッド呼び出しを行うと，オブジェクトのクラスに応じて適切なメソッドが選択され
呼び出される．

このような言語においてはクラス名とメソッド名の2つが決まればメソッドが一意に定まる．
逆に言えば，あるクラスのインスタンスを操作するメソッドを定義する際には，メソッドの内容の他に
クラス名とメソッド名の2つを指定しなければならない．
これに対し一般に変数を定義する際には，変数の内容の他に変数名を指定する必要がある．

ここで1つのアイデアが考えれられる．変数名の代わりに\textbf{クラス名とメソッド名の組}を用いることで，
変数と同じシンタックス，\textbf{かつ，同じセマンティクスで}メソッドを定義できるのではないか．

本研究の目的は，変数とメソッドの定義を同じシンタックスかつ同じセマンティクスで行う
プログラミング言語Suzuを試作し，この方式の利点および欠点を調査することである．
Suzuは変数とメソッドを共に\textbf{レキシカル環境}に定義するため，変数に対して行えるあらゆる操作が
メソッドに対しても自然に行える．
具体的には，ローカル変数に対応する\textbf{ローカルメソッド}を定義できる，
関数の仮引数としてメソッドを受け取れる，
モジュールシステムによってメソッドの可視性を制御できるなどの特徴を持つ．

本稿は次のような構成をとる．
第\ref{chapter:background}章ではオブジェクト指向言語における変数定義およびメソッド定義の方式
について述べる．
第\ref{chapter:implementation}章ではメソッドを変数と同様レキシカル環境に定義する
プログラミング言語Suzuの言語仕様を解説する．
第\ref{chapter:discussion}章では従来のオブジェクト指向言語の概念に対応するSuzuのプログラム例や
Suzu独自の特徴を生かしたプログラム例によって，このメソッド定義方式の利点および欠点について考察する．
第\ref{chapter:related-work}章で関連研究について，第\ref{chapter:future-work}章で今後の課題，
第\ref{chapter:conclusion}章で結論を述べる．


\chapter{変数定義とメソッド定義}
\label{chapter:background}

従来のオブジェクト指向言語における変数定義とメソッド定義の方式について分析し，
考案した新しいメソッド定義の方式について述べる．

\section{従来のオブジェクト指向言語}

クラスを持つオブジェクト指向言語においては，あるクラスのインスタンスを操作するメソッドを定義する際，
メソッドの内容の他にクラス名とメソッド名の2つを指定する必要がある．
これに対し変数を定義するには，変数の内容の他に変数名を指定する必要がある．
例えばプログラミング言語Rubyでは，
\begin{quote}
\begin{verbatim}
class C
  def m
    ...
  end
end
\end{verbatim}
\end{quote}
のようにしてクラス\verb|C|のインスタンスを操作するメソッド\verb|m|を定義でき，
\begin{quote}
\begin{verbatim}
v = ...
\end{verbatim}
\end{quote}
のようにして変数\verb|v|を定義できる．同様にJavaでは
\begin{quote}
\begin{verbatim}
class C {
  int m(){
    ...
  }
}
\end{verbatim}
\end{quote}
のようにしてメソッドを定義し，
\begin{quote}
\begin{verbatim}
int v = ...
\end{verbatim}
\end{quote}
のようにして変数を定義する．型指定を必要とするかどうかの違いはあるものの，どの言語においても
メソッドを定義するにはクラス名とメソッド名が必要で，変数を定義するには変数名が必要である．

変数定義とメソッド定義はこのようにシンタックスが異なるだけでなく，そのセマンティクスも大きく異なる．
RubyやJavaの場合メソッドはクラスに定義されるのに対し，変数はプログラムのブロック構造に対応する
レキシカル環境に定義される．
これによりプログラム内で局所的に有効なローカル変数を定義できる．

\section{考案したオブジェクト指向言語}

メソッド定義に必要なのはクラス名とメソッド名であり，変数定義に必要なのは変数名である．
では，変数名をクラス名とメソッド名の組に置き換えれば，変数定義と同じシンタックス・同じセマンティクスで
メソッドを定義できるのではないか．例えばシンタックスとしては，メソッドは
\begin{quote}
\begin{verbatim}
let C#m = ...
\end{verbatim}
\end{quote}
のようにして定義し，変数は
\begin{quote}
\begin{verbatim}
let v = ...
\end{verbatim}
\end{quote}
のようにして定義する．\verb|C#m|はクラス名\verb|C|とメソッド名\verb|m|の組である．

またメソッド定義のセマンティクスも変数と同様にする．つまりメソッドをクラスではなく，変数と同じレキシカル環境に
定義する．
これはローカル変数に対応するローカルメソッドの定義を可能とする．
この方式の利点および欠点を調査するため，レキシカル環境にメソッドを定義するオブジェクト指向言語Suzuを
試作した．


\chapter{プログラミング言語Suzu}
\label{chapter:implementation}

変数とメソッドを共にレキシカル環境に定義するプログラミング言語Suzuの言語仕様をコード例を交えて解説する．
コード例において式を省略する際は\verb|...|を用いる．

\section{基本的な要素}

変数は\verb|let|を用いて定義する．例えば変数\verb|x|を\verb|...|の値で初期化して定義するには
以下のようにする．
\begin{quote}
\begin{verbatim}
let x = ...
\end{verbatim}
\end{quote}

Suzuでは関数リテラルを記述できる．引数\verb|param1|，\verb|param2|を受け取って\verb|...|を
実行する関数は以下のように書ける．
\begin{quote}
\begin{verbatim}
^(param1, param2){ ... }
\end{verbatim}
\end{quote}

関数は\verb|def|を用いて定義できる．
\begin{quote}
\begin{verbatim}
def func(param1, param2):
  ...
end
\end{verbatim}
\end{quote}
これは以下のコードと等価である．
\begin{quote}
\begin{verbatim}
let func = ^(param1, param2){ ... }
\end{verbatim}
\end{quote}

関数\verb|func|を引数\verb|arg1|，\verb|arg2|で呼び出すには以下のようにする．
\begin{quote}
\begin{verbatim}
func(arg1, arg2)
\end{verbatim}
\end{quote}

最後の引数として関数リテラルを渡す際は専用の構文が使える．例えば
\begin{quote}
\begin{verbatim}
func(arg1, arg2, ^(param1, param2){ ... })
\end{verbatim}
\end{quote}
という関数呼び出しは
\begin{quote}
\begin{verbatim}
func(arg1, arg2)^(param1, param2):
  ...
end
\end{verbatim}
\end{quote}
と書ける．他の実引数や関数リテラルの仮引数，またはその両方がない場合，
\begin{quote}
\begin{verbatim}
func^(param1, param2):
  ...
end

func(arg1, arg2):
  ...
end

func:
  ...
end
\end{verbatim}
\end{quote}
のように省略して書ける．

Suzuでは\verb|:|からインデントの終わりまで（または\verb|{|から\verb|}|まで）をブロックと呼ぶ．
ブロック内のコードを実行する際は新たなレキシカル環境が生成され有効になり，実行が終わると破棄される．
変数は有効なレキシカル環境に定義される．よってブロック内で定義された変数はブロック内でのみ参照可能な
ローカル変数となる．例えば
\begin{quote}
\begin{verbatim}
def begin(thunk):
  thunk()
end
\end{verbatim}
\end{quote}
のような関数\verb|begin|を用いて
\begin{quote}
\begin{verbatim}
begin:
  let v = ...
  ...
end
\end{verbatim}
\end{quote}
と書いた場合，変数\verb|v|は\verb|begin|から\verb|end|内のみで有効なローカル変数である．

\section{オブジェクトシステム}

Suzuでは変数名の代わりにクラス名とメソッド名の組を指定し，メソッドを変数と同様レキシカル環境に定義する．
つまりメソッドを定義するには，
\begin{quote}
\begin{verbatim}
def C#m(self, param1, param2):
  ...
end
\end{verbatim}
\end{quote}
または
\begin{quote}
\begin{verbatim}
let C#m = ^(self, param1, param2){ ... }
\end{verbatim}
\end{quote}
のようにする．\verb|C|はクラス名，\verb|m|はメソッド名，\verb|C#m|はクラス名とメソッド名の組である．

定義したメソッドは\verb|C#m|と書くことで変数のように参照できる他，
\verb|inst|をクラス\verb|C|のインスタンスとすると以下のようにして呼び出せる．
\begin{quote}
\begin{verbatim}
inst.m(arg1, arg2)
\end{verbatim}
\end{quote}
このとき\verb|self|には\verb|inst|，\verb|param1|には\verb|arg1|，
\verb|param2|には\verb|arg2|の内容がそれぞれ代入される．
つまりメソッドの第1引数にはメソッド呼び出しの対象となったオブジェクト自身が，第2引数以降には実引数が渡される．

クラスは以下のようにして定義する．
\begin{quote}
\begin{verbatim}
class Point = make_point:
  x
  y
end
\end{verbatim}
\end{quote}
これにより，クラス\verb|Point|，コンストラクタ関数\verb|make_point|，
ゲッターメソッド\verb|Point#x|，\verb|Point#y|が定義される．
\verb|make_point|は\verb|x|と\verb|y|というフィールドを持った\verb|Point|のインスタンスを生成する
関数である．
フィールドへのアクセスは\verb|Point#x|，\verb|Point#y|を介してのみ行える．
例えば
\begin{quote}
\begin{verbatim}
let p = make_point(1, 2)
\end{verbatim}
\end{quote}
とすると，\verb|p.x|は\verb|1|，\verb|p.y|は\verb|2|となる．

クラス定義の際，
\begin{quote}
\begin{verbatim}
class Point = make_point:
  mutable x
  mutable y
end
\end{verbatim}
\end{quote}
のようにフィールド名の前に\verb|mutable|と書いた場合，上記に加えてセッターメソッド\verb|Point#(x=)|，
\verb|Point#(y=)|が定義される．
\begin{quote}
\begin{verbatim}
p.x = 3
p.y = 4
\end{verbatim}
\end{quote}
のような式は
\begin{quote}
\begin{verbatim}
p.(x=)(3)
p.(y=)(4)
\end{verbatim}
\end{quote}
と解釈されるため，これを用いて\verb|Point#(x=)|や\verb|Point#(y=)|を呼び出すことで
\verb|p|のフィールド\verb|x|，\verb|y|を書き換えられる．

ここまで述べてきたことから分かるように，Suzuではクラス定義とメソッド定義を分けて記述する．
つまりはクラスを定義した後に，そのクラスのインスタンスを操作するメソッドを自由に追加できる．
また，メソッドは変数と同様レキシカル環境に定義されるため，特定のブロック内でのみ有効な
ローカルメソッドを定義できる．

\section{モジュールシステム}


\chapter{プログラム例と考察}
\label{chapter:discussion}

\section{継承}
superとか

\section{アクセス制限}
protectedはない

\section{モジュール分割}
Visitorパターン？

\section{ローカルメソッド}
Refinements

\chapter{関連研究}
\label{chapter:related-work}

特異メソッド，EQLスペシャライザ，プロトタイプベース

CLOS，多重ディスパッチ

Classbox，Method Shells

Haskellの型クラス

OCamlのユーザー定義演算子

Scalaのimplicit conversion

.NETの拡張メソッド

MixJuice


\chapter{今後の課題}
\label{chapter:future-work}

\section{ダイナミックスコープ}

\section{効率的な実装}


\chapter{結論}
\label{chapter:conclusion}


\chapter*{謝辞}
\addcontentsline{toc}{chapter}{\numberline{}謝辞}

本研究を行うにあたり，多大なるご指導とご助言を下さった筑波大学システム情報系前田敦司准教授に
深く感謝いたします．
また第56回プログラミング・シンポジウムにて有益なコメントを下さった方々に感謝いたします．
最後に貴重なご意見を下さった筑波大学インタラクティブ・アーキテクチャ研究室の皆様とOBの水島宏太さんに
感謝いたします．

\newpage

%\addcontentsline{toc}{chapter}{\numberline{}参考文献}
\renewcommand{\bibname}{参考文献}

%% 参考文献に jbibtex を使う場合
\bibliographystyle{junsrt}
\bibliography{thesis}
%% [compile] jbibtex sample; platex sample; platex sample;

%% 参考文献を直接ファイルに含めて書く場合
%\begin{thebibliography}{1}
%\bibitem{RakRak}
%野寺隆志.
%\newblock 楽々 \LaTeX.
%\newblock 共立出版, 1990.
%
%\bibitem{JiyuuJizai}
%磯崎秀樹.
%\newblock \LaTeX 自由自在.
%\newblock サイエンス社, July 1992.
%
%\bibitem{bryant-ieeetc86}
%Randal~E. Bryant.
%\newblock Graph-based algorithms for {B}oolean function manipulation.
%\newblock {\em IEEE Transactions on Computers}, Vol. C-35, No.~8, pp. 677--691,
%  August 1986.
%\end{thebibliography}

\end{document}
