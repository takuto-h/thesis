%%
% このファイルは、筑波大学情報学群情報科学類の
% 卒業研究論文本体のサンプルです。
% このファイルを書き換えて、この例と同じような書式の論文本体を
% LaTeXを使って作成することができます。
% 
% PC環境や、LaTeX環境の設定によっては漢字コードや改行コードを
% 変更する必要があります。
%%
\documentclass[a4paper,11pt,dvipdfmx]{jreport}

%%【PostScript, JPEG, PNG等の画像の貼り込み】
%% 利用するパッケージを選んでコメントアウトしてください。
\usepackage{graphicx} % for \includegraphics[width=3cm]{sample.eps}
%\usepackage{epsfig} % for \psfig{file=sample.eps,width=3cm}
%\usepackage{epsf} % for \epsfile{file=sample.eps,scale=0.6}
%\usepackage{epsbox} % for \epsfile{file=sample.eps,scale=0.6}

%% dvipdfm を使う場合(dvi->pdfを直接生成する場合)
%\usepackage[dvipdfm]{color,graphicx}
%% dvipdfm を使ってPDFの「しおり」を付ける場合
%\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,bookmarkstype=toc]{hyperref}
%% 参考：dvipdfm 日本語版
%% http://hamilcar.phys.kyushu-u.ac.jp/~hirata/dvipdfm/

\usepackage[bookmarksnumbered=true]{hyperref}
\usepackage{pxjahyper}

\usepackage{times} % use Times Font instead of Computer Modern

\setcounter{tocdepth}{3}
\setcounter{page}{-1}

\setlength{\oddsidemargin}{0.1in}
\setlength{\evensidemargin}{0.1in} 
\setlength{\topmargin}{0in}
\setlength{\textwidth}{6in} 
%\setlength{\textheight}{10.1in}
\setlength{\parskip}{0em}
\setlength{\topsep}{0em}

%\newcommand{\zu}[1]{{\gt \bf 図\ref{#1}}}

%% タイトル生成用パッケージ(重要)
\usepackage{coins-jp}
\usepackage{jumoline}

%% タイトル
%% 【注意】タイトルの最後に\\ を入れるとエラーになります
\title{\Underline{レキシカル環境にメソッドを定義する\\オブジェクト指向言語Suzu}}
%% 著者
\author{林 拓人}
%% 指導教員
\advisor{前田敦司}

%% 専攻名 と 年月 (提出年月)
%% 年月は必要に応じて書き替えてください。
\heiseiyear{26}  % 平成の年度
\majorfield{ソフトウェアサイエンス主専攻}
%\majorfield{情報システム主専攻}
%\majorfield{知能情報メディア主専攻}

\makeatletter%% プリアンブルで定義する場合は必須

%% (j)report・(j)book クラスの場合
%% 
\renewenvironment{thebibliography}[1]% 再定義
{\chapter*{\bibname\@mkboth{\bibname}{\bibname}}%
	\addcontentsline{toc}{chapter}{\numberline{}\bibname}% この行追加
	\list{\@biblabel{\@arabic\c@enumiv}}%
	{\settowidth\labelwidth{\@biblabel{#1}}%
		\leftmargin\labelwidth
		\advance\leftmargin\labelsep
		\@openbib@code
		\usecounter{enumiv}%
		\let\p@enumiv\@empty
		\renewcommand\theenumiv{\@arabic\c@enumiv}}%
	\sloppy
	\clubpenalty4000
	\@clubpenalty\clubpenalty
	\widowpenalty4000%
	\sfcode`\.\@m}
{\def\@noitemerr
	{\@latex@warning{Empty `thebibliography' environment}}%
	\endlist}

\makeatother%% プリアンブルで定義する場合は必須

\usepackage{listings}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage

\thispagestyle{empty}
\vspace*{20pt plus 1fil}
\parindent=1zw
\noindent
%%
%% 論文の概要(Abstract)
%%
\begin{center}
{\Large \bf 要　　旨}
\vspace{2cm}
\end{center}

オブジェクト指向言語においてメソッドを定義するにはクラス名とメソッド名が必要である．
これに対し変数を定義するには変数名が必要となる．
ここで変数名の代わりにクラス名とメソッド名の組を用いれば，
変数と同じシンタックスかつ同じセマンティクスでメソッドを定義できるのではないか．

このメソッド定義方式の有用性を検証するため，メソッドを変数のようにレキシカル環境に
定義するプログラミング言語Suzuを試作した．
Suzuはこのメソッド定義方式によりローカル変数に対応するローカルメソッドが定義でき，
組み込みオブジェクトに対しメソッドを局所的に追加・再定義できる，
演算子のユーザー定義と組み合わせてグローバル環境を汚染せず可読性の高い内部DSLを
作成できる，
クラスではなくモジュールによってメソッドをグループ化・再利用できるという特徴を持つ．

既存のオブジェクト指向言語における類似した概念との関連についても議論する．

%%%%%
\par
\vspace{0pt plus 1fil}
\newpage

\pagenumbering{roman} % I, II, III, IV 
\tableofcontents
%\listoffigures
%\listoftables

\pagebreak \setcounter{page}{1}
\pagenumbering{arabic} % 1,2,3


\chapter{序論}

オブジェクト指向言語とは，オブジェクト指向プログラミングの支援機構を持つ
プログラミング言語の総称である．
多くのオブジェクト指向言語が持つ概念としてクラスとメソッドが挙げられる．
クラスはオブジェクトの属性，メソッドはオブジェクトに対する操作である．
あるクラスを属性として持つオブジェクトをそのクラスのインスタンスと呼ぶ．
オブジェクトに対しメソッド名を指定してメソッド呼び出しを行うと，
オブジェクトのクラスに応じて適切なメソッドが選択され呼び出される．

このような言語においてはクラス名とメソッド名の2つが決まればメソッドが一意に定まる．
逆に言えば，あるクラスのインスタンスを操作するメソッドを定義する際には，
メソッドの内容の他にクラス名とメソッド名の2つを指定しなければならない．
これに対し一般に変数を定義する際には，変数の内容の他に変数名を指定する必要がある．

ここで1つのアイデアが考えれられる．
変数名の代わりに\textbf{クラス名とメソッド名の組}を用いることで，
変数と同じシンタックス，\textbf{かつ，同じセマンティクスで}
メソッドを定義できるのではないか．
これを採用するメリットとしては，ローカル変数に対応する\textbf{ローカルメソッド}を
定義できること，関数の仮引数として変数のみならずメソッドを指定できること，
メソッドの可視性の制御に変数と同じモジュールシステムを活用できることなどが
ある．

本研究の目的は，変数とメソッドの定義を同じシンタックスかつ同じセマンティクスで行う
プログラミング言語Suzuを試作し，その有用性を検証することである．
Suzuは特にユーザー定義演算子をローカルメソッドとして定義することで，
可読性の高い内部DSLを衝突のリスクを気にすることなく気軽に利用できるよう
設計されている．

本稿は次のような構成をとる．
第\ref{chapter:proposal}章ではオブジェクト指向言語における変数定義および
メソッド定義の方式について述べる．
第\ref{chapter:implementation}章では変数とメソッドを同等の仕組みで
定義するプログラミング言語Suzuの言語仕様を解説する．
第\ref{chapter:discussion}章ではSuzuのメソッド定義方式による特徴を生かした
プログラム例によってその有用性を検証する．
第\ref{chapter:related-work}章で関連研究について，
第\ref{chapter:future-work}章で今後の課題，
第\ref{chapter:conclusion}章で結論を述べる．


\chapter{提案}
\label{chapter:proposal}

従来のオブジェクト指向言語における変数定義とメソッド定義の方式について分析し，
考案した新しいメソッド定義の方式について述べる．

\section{従来のオブジェクト指向言語}

クラスを持つオブジェクト指向言語においては，あるクラスのインスタンスを操作する
メソッドを定義する際，メソッドの内容の他にクラス名とメソッド名の2つを指定する
必要がある．
これに対し変数を定義するには，変数の内容の他に変数名を指定する必要がある．
例えばプログラミング言語Rubyでは，
\begin{quote}
\begin{verbatim}
class C
  def m
    ...
  end
end
\end{verbatim}
\end{quote}
のようにしてクラス\verb|C|のインスタンスを操作するメソッド\verb|m|を定義でき，
\begin{quote}
\begin{verbatim}
v = ...
\end{verbatim}
\end{quote}
のようにして変数\verb|v|を定義できる．同様にJavaでは
\begin{quote}
\begin{verbatim}
class C {
  int m(){
    ...
  }
}
\end{verbatim}
\end{quote}
のようにしてメソッドを定義し，
\begin{quote}
\begin{verbatim}
int v = ...
\end{verbatim}
\end{quote}
のようにして変数を定義する．型指定を必要とするかどうかの違いはあるものの，
どの言語においてもメソッドを定義するにはクラス名とメソッド名が必要で，
変数を定義するには変数名が必要である．

変数定義とメソッド定義はこのようにシンタックスが異なるだけでなく，
そのセマンティクスも大きく異なる．
RubyやJavaの場合メソッドはクラスに定義されるのに対し，
変数はプログラムのブロック構造に対応するレキシカル環境に定義される．
これによりプログラム内で局所的に有効なローカル変数を定義できる．

\section{考案したオブジェクト指向言語}

メソッド定義に必要なのはクラス名とメソッド名であり，変数定義に必要なのは変数名である．
では，変数名をクラス名とメソッド名の組に置き換えれば，
変数定義と同じシンタックス・同じセマンティクスでメソッドを定義できるのではないか．
例えばシンタックスとしては，メソッドは
\begin{quote}
\begin{verbatim}
let C#m = ...
\end{verbatim}
\end{quote}
のようにして定義し，変数は
\begin{quote}
\begin{verbatim}
let v = ...
\end{verbatim}
\end{quote}
のようにして定義する．\verb|C#m|はクラス名\verb|C|とメソッド名\verb|m|の組である．

またメソッド定義のセマンティクスも変数と同様にする．つまりメソッドをクラスではなく，
変数と同じレキシカル環境に定義する．
これはローカル変数に対応するローカルメソッドの定義を可能とする．
この方式の有用性を検証するため，レキシカル環境にメソッドを定義する
オブジェクト指向言語Suzuを試作した．


\chapter{プログラミング言語Suzu}
\label{chapter:implementation}

変数とメソッドを共にレキシカル環境に定義するプログラミング言語Suzuの言語仕様を
コード例を交えて解説する．
コード例において式を省略する際は\verb|...|を用いる．

\section{基本的な要素}

変数は\verb|let|を用いて定義する．例えば変数\verb|v|を\verb|...|の値で
初期化して定義するには以下のようにする．
\begin{quote}
\begin{verbatim}
let v = ...
\end{verbatim}
\end{quote}

Suzuでは関数リテラルを記述できる．引数\verb|param1|，\verb|param2|を受け取って
\verb|...|を実行する関数は以下のように書ける．
\begin{quote}
\begin{verbatim}
^(param1, param2){ ... }
\end{verbatim}
\end{quote}

関数は\verb|def|を用いて定義できる．
\begin{quote}
\begin{verbatim}
def func(param1, param2):
  ...
end
\end{verbatim}
\end{quote}
これは以下のコードと等価である．
\begin{quote}
\begin{verbatim}
let func = ^(param1, param2){ ... }
\end{verbatim}
\end{quote}

関数\verb|func|を引数\verb|arg1|，\verb|arg2|で呼び出すには以下のようにする．
\begin{quote}
\begin{verbatim}
func(arg1, arg2)
\end{verbatim}
\end{quote}

最後の引数として関数リテラルを渡す際は専用の構文が使える．例えば
\begin{quote}
\begin{verbatim}
func(arg1, arg2, ^(param1, param2){ ... })
\end{verbatim}
\end{quote}
という関数呼び出しは
\begin{quote}
\begin{verbatim}
func(arg1, arg2)^(param1, param2):
  ...
end
\end{verbatim}
\end{quote}
と書ける．他の実引数や関数リテラルの仮引数，またはその両方がない場合，
\begin{quote}
\begin{verbatim}
func^(param1, param2):
  ...
end

func(arg1, arg2):
  ...
end

func:
  ...
end
\end{verbatim}
\end{quote}
のように省略して書ける．

Suzuでは\verb|:|からインデントの終わりまで（または\verb|{|から\verb|}|まで）を
ブロックと呼ぶ．
ブロック内のコードを実行する際は新たなレキシカル環境が生成され有効になり，
実行が終わると破棄される．
変数は有効なレキシカル環境に定義される．よってブロック内で定義された変数は
ブロック内でのみ参照可能なローカル変数となる．例えば
\begin{quote}
\begin{verbatim}
def begin(thunk):
  thunk()
end
\end{verbatim}
\end{quote}
のような関数\verb|begin|を用いて
\begin{quote}
\begin{verbatim}
begin:
  let v = ...
  ...
end
\end{verbatim}
\end{quote}
と書いた場合，変数\verb|v|は\verb|begin|から\verb|end|内のみで有効な
ローカル変数である．

\section{オブジェクトシステム}

Suzuでは変数名の代わりにクラス名とメソッド名の組を指定し，メソッドを変数と同様
レキシカル環境に定義する．
つまりメソッドを定義するには，
\begin{quote}
\begin{verbatim}
def C#m(self, param1, param2):
  ...
end
\end{verbatim}
\end{quote}
または
\begin{quote}
\begin{verbatim}
let C#m = ^(self, param1, param2){ ... }
\end{verbatim}
\end{quote}
のようにする．\verb|C|はクラス名，\verb|m|はメソッド名，\verb|C#m|は
クラス名とメソッド名の組である．

定義したメソッドは\verb|C#m|と書くことで変数のように参照できる他，
\verb|inst|をクラス\verb|C|のインスタンスとすると以下のようにして呼び出せる．
\begin{quote}
\begin{verbatim}
inst.m(arg1, arg2)
\end{verbatim}
\end{quote}
このとき\verb|self|には\verb|inst|，\verb|param1|には\verb|arg1|，
\verb|param2|には\verb|arg2|の内容がそれぞれ代入される．
つまりメソッドの第1引数にはメソッド呼び出しの対象となったオブジェクト自身が，
第2引数以降には実引数が渡される．

クラスは以下のようにして定義する．
\begin{quote}
\begin{verbatim}
class Point = make_point:
  x
  y
end
\end{verbatim}
\end{quote}
これにより，クラス\verb|Point|，コンストラクタ関数\verb|make_point|，
ゲッターメソッド\verb|Point#x|，\verb|Point#y|が定義される．
\verb|make_point|は\verb|x|と\verb|y|というフィールドを持った
\verb|Point|のインスタンスを生成する関数である．
フィールドへのアクセスは\verb|Point#x|，\verb|Point#y|を介してのみ行える．
例えば
\begin{quote}
\begin{verbatim}
let p = make_point(1, 2)
\end{verbatim}
\end{quote}
とすると，\verb|p.x|は\verb|1|，\verb|p.y|は\verb|2|となる．

クラス定義の際，
\begin{quote}
\begin{verbatim}
class Point = make_point:
  mutable x
  mutable y
end
\end{verbatim}
\end{quote}
のようにフィールド名の前に\verb|mutable|と書いた場合，上記に加えて
セッターメソッド\verb|Point#(x=)|，\verb|Point#(y=)|が定義される．
\begin{quote}
\begin{verbatim}
p.x = 3
p.y = 4
\end{verbatim}
\end{quote}
のような式は
\begin{quote}
\begin{verbatim}
p.(x=)(3)
p.(y=)(4)
\end{verbatim}
\end{quote}
というメソッド呼び出しに解釈されるため，これを用いて\verb|Point#(x=)|や
\verb|Point#(y=)|を呼び出すことで\verb|p|のフィールド\verb|x|，\verb|y|を
書き換えられる．

Suzuでは演算子の適用もメソッド呼び出しとして解釈される．
正規表現\verb$[-+*/%&|=<>]+$にマッチする文字列は演算子として扱われ，
優先順位や結合則は演算子の1文字目に依存する．
例えば
\begin{quote}
\begin{verbatim}
x <- y
\end{verbatim}
\end{quote}
という式は
\begin{quote}
\begin{verbatim}
x.(<-)(y)
\end{verbatim}
\end{quote}
と解釈される．優先順位や結合則は\verb|<|と同じである．

ここまで述べてきたことから分かるように，Suzuではクラス定義とメソッド定義を
分けて記述する．
つまりはクラスを定義した後に，そのクラスのインスタンスを操作するメソッドを
自由に追加できる．
また，メソッドは変数と同様レキシカル環境に定義されるため，特定のブロック内でのみ
有効なローカルメソッドを定義できる．
さらに演算子の適用もメソッド呼び出しとして解釈されるため，ローカルメソッドを
定義することでクラスごとの演算子の意味を局所的に変えることもできる．

\section{モジュールシステム}

Suzuはメソッドを変数と同様レキシカル環境に定義する．そのため可視性の制御も変数と同様
モジュールによって行う．

モジュールを定義するには以下のようにする．
\begin{quote}
\begin{verbatim}
module M:
  let f = ...
  let C#m = ...
  ...
  export f, C#m
end
\end{verbatim}
\end{quote}
これにより，変数\verb|f|とメソッド\verb|C#m|をエクスポートするモジュール
\verb|M|が定義される．
\verb|let|（または\verb|def|）を用いて変数やメソッドを定義した後，
\verb|export|の後にエクスポートしたい変数の変数名や，メソッドを表すクラス名と
メソッド名の組を並べて指定する．
エクスポートされている変数やメソッドは\verb|::|を用いて，
\verb|M::f|，\verb|M::(C#m)|のように参照できる．
モジュール内で定義した変数やメソッドをエクスポートしなかった場合，
それらはモジュール内でのみ有効なモジュールローカルな変数，またはメソッドとなる．

モジュールは任意のスコープで\verb|open|できる．例えば
\begin{quote}
\begin{verbatim}
begin:
  open M
  ...
end
\end{verbatim}
\end{quote}
とすると，\verb|begin|から\verb|end|までのブロックで\verb|M|から
エクスポートされている変数やメソッドを修飾子なしで参照できるようになる．
\verb|M|を先ほど定義したものとすると，\verb|f|，\verb|C#m|のように
変数やメソッドを参照可能となる．

既存のモジュールを活用して新しいモジュールを定義する際は
\verb|include|が便利である．
\begin{quote}
\begin{verbatim}
module B:
  include A
  ...
end
\end{verbatim}
\end{quote}
この例ではモジュール\verb|B|内でモジュール\verb|A|を\verb|include|している．
\verb|include A|とするとまず\verb|open A|が行われ，次に\verb|A|から
エクスポートされている
変数やメソッドをすべて\verb|B|からもエクスポートする．
これによりモジュール\verb|A|を拡張した新たなモジュール\verb|B|を容易に定義できる．

\verb|open|や\verb|include|によって新しく参照可能になる変数やメソッドが
衝突する場合，そのコードはエラーとなる．
例えば以下のコードは\verb|open Y|で\verb|C#q|が衝突するためエラーとなる．
\begin{quote}
\begin{verbatim}
module X:
  ... 
  export C#p, C#q
end
module Y:
  ...
  export C#q, C#r
end
begin:
  open X
  open Y
  ...
end
\end{verbatim}
\end{quote}
これを回避するには\verb|except|を用いる．
\begin{quote}
\begin{verbatim}
begin:
  open X except C#q
  open Y
  ...
end
\end{verbatim}
\end{quote}
この例では\verb|X|を\verb|open|する際\verb|C#q|を\verb|except|している．
これによりこの時点で\verb|C#q|はインポートされない．
よって\verb|open Y|としてもエラーは起きない．

Suzuにはパラメータ化されたモジュールとしてのトレイトという機構がある．
トレイトは値を受け取ってモジュールを返す関数である．
\begin{quote}
\begin{verbatim}
trait T(param1, param2):
  let f = ...
  let C#m = ...
  ...
  export f, C#m
end
\end{verbatim}
\end{quote}
この例では\verb|param1|と\verb|param2|を受け取って，\verb|f|と\verb|C#m|を
エクスポートするモジュールを返すトレイト\verb|T|を定義している．
トレイトの活用法については第\ref{chapter:discussion}章で述べる．


\chapter{考察}
\label{chapter:discussion}

Suzuのローカルメソッドやユーザー定義演算子，モジュールシステムを生かした
プログラム例によって，
レキシカル環境にメソッドを定義することの有用性について検証する．
なお，\verb|p|は引数として受け取った値を出力する関数，
\verb|//|から行末まではコメントである．
ここではコメントとして\verb|//=>|の後にプログラムの出力内容を記述する．

\section{組み込みオブジェクトに対するメソッドの追加}

まず整数値に対するメソッドを複数提供する\verb|Seconds|というモジュールを
例に挙げる．
\begin{quote}
\begin{verbatim}
module Seconds:
  let Int::C#minutes = ...
  let Int::C#hours = ...
  ...
end

begin:
  open Seconds
  p(3.minutes) //=> 180
  p(2.hours)   //=> 7200
end
\end{verbatim}
\end{quote}
\verb|Seconds|をローカル環境でオープンすると，定義されているメソッドが
そのスコープでのみ有効になる．
\verb|Seconds|は分や時間を秒に変換する自然言語に近い読み方のできるメソッドを
提供しており，例えば\verb|3.minutes|が\verb|180|，\verb|2.hours|が
\verb|7200|となる．
\verb|Int::C|というのはモジュール\verb|Int|内の変数\verb|C|で，
整数値のクラス名を指している．
整数値のような組み込みオブジェクトに対するメソッドを衝突のリスクを気にする
ことなく追加できるのは利点である.


\section{メソッドの柔軟なグループ化}

Suzuのメソッド定義はクラス定義とは独立しており，モジュールに所属する形で
定義することができる．
そのため対象のクラスによらず関連性の高いメソッドを集めて柔軟にグループ化できる．

以下の例ではいくつかの組み込みオブジェクトに対しJSON化メソッド
\verb|to_json|を提供するモジュール\verb|ToJSON|を定義している.
\begin{quote}
\begin{verbatim}
module ToJSON:
  let Int::C#to_json = ...
  let String::C#to_json = ...
  let List::C#to_json = ...
  ...
end

begin:
  open ToJSON:
  p([1,2,3].to_json) //=> "[1,2,3]"
end
\end{verbatim}
\end{quote}
このような変換処理を行うにはクラスごとに同名のメソッドを定義する必要があり，
クラスにメソッドを定義する言語では定義が各クラスに分散してしまう．
Suzuはレキシカル環境にメソッドを定義するためメソッド群をモジュールとして提供でき，
関連するメソッドを1箇所にまとめて定義することができる．


\section{演算子の局所的な再定義}

Suzuでは演算子の適用がメソッド呼び出しとして扱われる．そのため演算子に対応する
メソッドを局所的に再定義することで，その振る舞いを変えることができる．

例えば整数同士の割り算を行うメソッド\verb|Int::C#(/)|は，組み込みのものは
整数を返す．しかしながら以下のように修正版のメソッドを提供するモジュールを
定義して\verb|open|することで，これを特定のブロックでのみ浮動小数点数を
返すように変えることができる.
\begin{quote}
\begin{verbatim}
module Quotient:
  let Int::C#(/) = ...
  ...
end

p(3 / 2) //=> 1
begin:
  open Quotient
  p(3 / 2) //=> 1.5
end
p(3 / 2) //=> 1
\end{verbatim}
\end{quote}

\section{内部DSL}

Suzuは演算子をユーザー定義する際の自由度が高い．
演算子をローカルメソッドとして定義すれば,グローバル環境を汚染せず可読性の高い
言語内DSLを作成できる.
以下の例では演算子式によって正規表現を構築できるDSLを提供するモジュール
\verb|PrettyRegex|を定義している.
\begin{quote}
\begin{verbatim}
module PrettyRegex:
  let String::C#(|) = ...
  let Char::C#(-) = ...
  ...
end

let regex = begin:
  open PrettyRegex
  ("foo"|"bar")+('0'-'9').one_or_more
end
p(regex) //=> "(foo|bar)[0-9]+"
\end{verbatim}
\end{quote}
縦棒やハイフンといった衝突の危険が高いと思われる短い演算子も，
スコープを限定して定義することで安心して使用できる.

\section{パラメータ化されたモジュール}

Suzuにはパラメータ化されたモジュールとしてのトレイトという機能がある．
トレイトを使うと，対象のクラスと必要なメソッドを与えることで
複数のメソッドを提供するモジュールを返す関数を書くことができる．

例えば以下の例では\verb|BankAccount|と\verb|StockAccount|に
共通するメソッドをトレイト\verb|Account|によって提供している．
\begin{quote}
\begin{verbatim}
trait Account(C, C#balance, ...):
  ...
  export C#deposit!, C#withdraw!
end

open Account(BankAccount, BankAccount#balance, ...)
open Account(StockAccount, StockAccount#balance, ...)
\end{verbatim}
\end{quote}
トレイト\verb|Account|はクラス\verb|C|とメソッド\verb|C#balance|を
受け取って，メソッド\verb|C#deposit!|，\verb|C#withdraw!|を提供する
モジュールを返す関数である．
戻り値のモジュールを\verb|open|することでそのスコープでメソッドが有効になる．
これは，\verb|C#balance|が定義されている任意のクラス\verb|C|に
\verb|C#deposit!|および\verb|C#withdraw!|を提供する関数であると言える．


\section{多重継承の代替}

トレイトは多重継承の代替機構としても利用できる.
以下の例ではメソッド\verb|read|を定義するトレイト\verb|Readable|と
\verb|write|を定義する\verb|Writable|をクラス\verb|ReadWriteStream|
に対して呼び出し\verb|open|することで，\verb|read|と\verb|write|の
両方のメソッドを提供している．
\begin{quote}
\begin{verbatim}
trait Readable(C, ...):
  let C#read = ...
  ...
end

trait Writable(C, ...):
  let C#write = ...
  ...
end

open Readable(ReadWriteStream, ...)
open Writable(ReadWriteStream, ...)
\end{verbatim}
\end{quote}
もしメソッドの衝突が起きるようならばエラーが起きるため，
\verb|except|を使って適切に回避する必要がある．

このように，Suzuはメソッドをクラスではなくレキシカル環境に定義するため，
モジュールシステムによってメソッドを整理・再利用・局所的に有効化することが
できる．


\chapter{関連研究}
\label{chapter:related-work}

Suzuのメソッド定義方式がもたらすのと類似した柔軟性を持つ既存の概念について
述べる．

GluonJ\cite{GluonJ}はアスペクト指向プログラミングを支援するJavaの拡張である．
Glueと呼ばれるクラスを定義することで既存のクラスの外部でメソッドを
定義できるが，再定義の影響範囲を限定することができない．

C\#の拡張メソッド\cite{ExtentionMethods}は既存のクラスにメソッドを
追加したように見せることができる．
実際に呼ばれるのは第1引数に\verb|this|と指定した静的メソッドである．
拡張メソッドは\verb|using|ディレクティブによって有効無効を制御できるが，
同じシグネチャを持つ拡張メソッドが複数存在する場合エラーが起き，
またこれを回避する仕組みを持たない．

Scala\cite{Scala}のimplicit conversionも既存のクラスに対しメソッドを
追加したように見せる機能である．
実際は存在しないメソッドが呼ばれた際に型変換を行うことで，別のクラスのメソッドを
呼び出している．
スコープはブロック単位で制御できるが，同じシグネチャのメソッドを提供する
型への変換が複数存在する場合エラーが起き，これを回避する仕組みを持たない．

Haskellの型クラス\cite{TypeClasses}はオブジェクト指向プログラミングのための
機構ではないが，
データ型の定義と独立して型ごとに操作を定義できる点がSuzuのメソッドに類似している．
型クラスは導入に静的な型を必要とするが，Suzuのメソッドはこれを必要としない．
また型クラスにおいて操作の実体を定義するインスタンス宣言は
モジュールシステムによって個別にエクスポートするかどうかの指定ができない．
ただし型クラスは戻り値の型に応じて関数の振る舞いを変えさせることができるのに対し，
Suzuではこれは不可能である．

OCaml\cite{OCaml}のlocal openはSuzuと同様モジュール内の変数を局所的に
インポートできる．
これとユーザー定義演算子を組み合わせると演算子の意味を局所的に変えられる．
しかしOCamlにはオーバーロードが無いため演算子の振る舞いを型ごとに
変えることができず，既存の演算子を上書きしてしまうため内部DSLを構築するには
不便である．

Traits\cite{Traits,ApplyingTraits}はSuzuのトレイトの元となった概念である．
メソッドの集合であるトレイトに対し合成やリネームなどの演算を行うことで，
メソッドの衝突を回避しつつクラスにメソッドを提供できる．
Suzuはクラスではなくレキシカル環境にメソッドを定義するため，
トレイトを値を受け取ってモジュールを返す関数としてとらえ直した．
この方式では必要なメソッドと提供するメソッドが関数の引数と戻り値として明確となり，
モジュール演算によってメソッドの衝突を回避できることを示した．

CLOS\cite{CLOS}はCommon Lispの言語仕様に含まれるオブジェクト指向
プログラミングの支援機構で，メソッドをクラスとは独立して定義する．
メソッドはクラスではなく総称関数に対して追加され，総称関数は引数として
与えられたオブジェクトに応じて適切なメソッドを選択し呼び出す．
CLOSはCLtL2\cite{CLtL2}と呼ばれる仕様では既存の総称関数の内容を
コピーしてローカルな総称関数を定義する\verb|with-added-methods|が
含まれていたが，最新の仕様からは削除されている．
これはメソッドのローカル定義が有用でないと判断されたためだが，
Suzuは非S式文法の言語におけるユーザー定義演算子との組み合わせによって
ローカルメソッドの有効な利用法を示した．

Classbox\cite{Classboxes}，Refinements\cite{Refinements}，
Method Shells\cite{MethodShells}は，いずれも既存の
オブジェクト指向言語に対しモジュール単位でスコープを限定したメソッドの
追加・再定義を行うための機構である．
違いはメソッドのスコープルールであり，Classboxはダイナミックスコープ，
Refinementsはレキシカルスコープ，Method Shellsはそれらを切り替えられる．
SuzuのモジュールシステムはRefinementsに近い．ただしSuzuは
モジュール単位のみならずブロック単位でメソッドの追加・再定義が行え，
内部DSLの構築の際により利便性が高い．

MixJuice\cite{MixJuice}はクラス定義を複数のモジュールに分割して
書くことができる言語である．
MixJuiceによるモジュール分割はSuzuが行えるそれと非常に類似している．
MixJuiceにはパラメータ化されたモジュールがなく，
Suzuには静的な型検査がないという違いがある．


\chapter{今後の課題}
\label{chapter:future-work}

\section{多重ディスパッチ}

1つのオブジェクトのクラスに応じてメソッドの選択を行う単一ディスパッチに対し，
複数のオブジェクトのクラスに応じてメソッドの選択を行うのが多重ディスパッチである．
Suzuは単一ディスパッチにしか対応していないが，メソッドはクラスではなく
レキシカル環境に定義されているためディスパッチで考慮するクラスを
1つに限定する必要はなく，多重ディスパッチが可能なCLOSに倣えば原理上は比較的容易に
多重ディスパッチに対応できると考えられる．

問題は適切なシンタックスを考案することである．内部DSLの構築にあたっては
語順も重要な要素なので，なるべく語順を崩すことのない文法が必要である．

\section{ダイナミックスコープ}

Suzuのメソッドは変数と同じレキシカルスコープである．
これにより演算子を用いた内部DSLを構築する際，外部の関数呼び出し時に
演算子の振る舞いが変わっているために破綻してしまうようなことが起きない
ようになっている．

しかしながらダイナミックスコープであるほうが有用な場合もある．
例えば値を出力する関数\verb|print|が内部で値に対しメソッド\verb|to_string|
を呼び出しているとすると，ダイナミック環境の\verb|to_string|を再定義することで
局所的に出力内容を変えることができる．

レキシカル・ダイナミック共に有用であるため，ユースケースを分析し
適切な方法で共存させつつ導入する必要がある．

\section{オブジェクト固有のメソッド}

Rubyの特異メソッド，Common LispのEQLスペシャライザ，あるいはECMAScript
\cite{ECMAScript}のようなプロトタイプベースのオブジェクト指向言語を用いると，
オブジェクトに対しクラスによらない固有のメソッドを定義できる．
Suzuは現状そのような仕組みは持っておらず，オブジェクト固有のメソッドは定義できない．
しかしながらまずはこれら既存の仕組みの有用性自体を検証する必要がある．

\section{効率的な実装}

Suzuではブロックという細かい単位でメソッドの再定義ができる．
これはつまり同じメソッド呼び出しでもプログラムのどの位置に書かれたかによって
呼び出されるメソッドが変化するということであり，
キャッシュを効かせにくいという欠点がある．
現在Suzuの処理系はメソッド呼び出しに関して特に最適化を施しておらず，
適切な最適化手法を考え実装することが課題である．

\section{オブジェクトのmix}

\chapter{結論}
\label{chapter:conclusion}

メソッドを変数と同様レキシカル環境に定義するオブジェクト指向言語Suzuを試作した．
変数名の代わりにクラス名とメソッド名の組を用いることで，
変数とメソッドを同じシンタックス，かつ，同じセマンティクスで定義できる．
これによりローカル変数に対応するローカルメソッドが定義したり，
クラスではなくモジュールによってメソッドの可視性を制御したり，
メソッドによってパラメータ化されたモジュールを定義したりすることができる．

これらの特徴は実際のプログラミングにおいて有用である．
組み込みオブジェクトに対するメソッドの追加または再定義したり，
ローカルメソッドをユーザー定義演算子と組み合わせてグローバル環境を汚染しない
可読性の高い内部DSLを構築したり，
クラスごとにまとめるのではなくモジュールによって関連性の高いメソッドを1箇所に
まとめて定義したり，
パラメータ化さたモジュールによって衝突回避を行いながら多重継承に相当する
モジュールの再利用ができたりといった具体例を挙げた

従来の研究と比べメソッドのスコープをブロックという細かい単位で制限でき，
かつ衝突回避のための機構を持つことがSuzuの優れている点である．

今後は他のオブジェクト指向言語が持つ機能への対応や効率的な実装が課題である．


\chapter*{謝辞}
\addcontentsline{toc}{chapter}{\numberline{}謝辞}

本研究を行うにあたり，多大なるご指導とご助言を下さった筑波大学システム情報系
前田敦司准教授に深く感謝いたします．
また第56回プログラミング・シンポジウムにて有益なコメントを下さった方々に
感謝いたします．
最後に貴重なご意見を下さった筑波大学インタラクティブ・アーキテクチャ研究室の皆様と
OBの水島宏太さんに感謝いたします．

\newpage

\nocite{ContextJ}
\nocite{C3Linearization}
\nocite{CISCO}
\nocite{OptimizingMessageSends}
\nocite{MethodCachingForRuby}
\nocite{ShiftResetTutorial}
\nocite{ShiftResetOnMinCaml}
\nocite{ExnAndDelimCont}
%\addcontentsline{toc}{chapter}{\numberline{}参考文献}
\renewcommand{\bibname}{参考文献}

%% 参考文献に jbibtex を使う場合
\bibliographystyle{junsrt}
\bibliography{thesis}
%% [compile] jbibtex sample; platex sample; platex sample;

%% 参考文献を直接ファイルに含めて書く場合
%\begin{thebibliography}{1}
%\bibitem{RakRak}
%野寺隆志.
%\newblock 楽々 \LaTeX.
%\newblock 共立出版, 1990.
%
%\bibitem{JiyuuJizai}
%磯崎秀樹.
%\newblock \LaTeX 自由自在.
%\newblock サイエンス社, July 1992.
%
%\bibitem{bryant-ieeetc86}
%Randal~E. Bryant.
%\newblock Graph-based algorithms for {B}oolean function manipulation.
%\newblock {\em IEEE Transactions on Computers}, Vol. C-35, No.~8, pp. 677--691,
%  August 1986.
%\end{thebibliography}

\end{document}
