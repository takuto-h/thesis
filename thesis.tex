%%
% このファイルは、筑波大学情報学群情報科学類の
% 卒業研究論文本体のサンプルです。
% このファイルを書き換えて、この例と同じような書式の論文本体を
% LaTeXを使って作成することができます。
% 
% PC環境や、LaTeX環境の設定によっては漢字コードや改行コードを
% 変更する必要があります。
%%
\documentclass[a4paper,11pt,dvipdfmx]{jreport}

%%【PostScript, JPEG, PNG等の画像の貼り込み】
%% 利用するパッケージを選んでコメントアウトしてください。
\usepackage{graphicx} % for \includegraphics[width=3cm]{sample.eps}
%\usepackage{epsfig} % for \psfig{file=sample.eps,width=3cm}
%\usepackage{epsf} % for \epsfile{file=sample.eps,scale=0.6}
%\usepackage{epsbox} % for \epsfile{file=sample.eps,scale=0.6}

%% dvipdfm を使う場合(dvi->pdfを直接生成する場合)
%\usepackage[dvipdfm]{color,graphicx}
%% dvipdfm を使ってPDFの「しおり」を付ける場合
%\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,bookmarkstype=toc]{hyperref}
%% 参考：dvipdfm 日本語版
%% http://hamilcar.phys.kyushu-u.ac.jp/~hirata/dvipdfm/

\usepackage[bookmarksnumbered=true]{hyperref}
\usepackage{pxjahyper}

\usepackage{times} % use Times Font instead of Computer Modern

\setcounter{tocdepth}{3}
\setcounter{page}{-1}

\setlength{\oddsidemargin}{0.1in}
\setlength{\evensidemargin}{0.1in} 
\setlength{\topmargin}{0in}
\setlength{\textwidth}{6in} 
%\setlength{\textheight}{10.1in}
\setlength{\parskip}{0em}
\setlength{\topsep}{0em}

%\newcommand{\zu}[1]{{\gt \bf 図\ref{#1}}}

%% タイトル生成用パッケージ(重要)
\usepackage{coins-jp}
\usepackage{jumoline}

%% タイトル
%% 【注意】タイトルの最後に\\ を入れるとエラーになります
\title{\Underline{レキシカル環境にメソッドを定義する\\オブジェクト指向言語Suzu}}
%% 著者
\author{林 拓人}
%% 指導教員
\advisor{前田敦司}

%% 専攻名 と 年月 (提出年月)
%% 年月は必要に応じて書き替えてください。
\heiseiyear{26}  % 平成の年度
\majorfield{ソフトウェアサイエンス主専攻}
%\majorfield{情報システム主専攻}
%\majorfield{知能情報メディア主専攻}

\makeatletter%% プリアンブルで定義する場合は必須

%% (j)report・(j)book クラスの場合
%% 
\renewenvironment{thebibliography}[1]% 再定義
{\chapter*{\bibname\@mkboth{\bibname}{\bibname}}%
	\addcontentsline{toc}{chapter}{\numberline{}\bibname}% この行追加
	\list{\@biblabel{\@arabic\c@enumiv}}%
	{\settowidth\labelwidth{\@biblabel{#1}}%
		\leftmargin\labelwidth
		\advance\leftmargin\labelsep
		\@openbib@code
		\usecounter{enumiv}%
		\let\p@enumiv\@empty
		\renewcommand\theenumiv{\@arabic\c@enumiv}}%
	\sloppy
	\clubpenalty4000
	\@clubpenalty\clubpenalty
	\widowpenalty4000%
	\sfcode`\.\@m}
{\def\@noitemerr
	{\@latex@warning{Empty `thebibliography' environment}}%
	\endlist}

\makeatother%% プリアンブルで定義する場合は必須

\usepackage{listings}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage

\thispagestyle{empty}
\vspace*{20pt plus 1fil}
\parindent=1zw
\noindent
%%
%% 論文の概要(Abstract)
%%
\begin{center}
{\Large \bf 要　　旨}
\vspace{2cm}
\end{center}
[400字程度]

%%%%%
\par
\vspace{0pt plus 1fil}
\newpage

\pagenumbering{roman} % I, II, III, IV 
\tableofcontents
%\listoffigures
%\listoftables

\pagebreak \setcounter{page}{1}
\pagenumbering{arabic} % 1,2,3


\chapter{序論}

オブジェクト指向言語とは，オブジェクト指向プログラミングの支援機構を持つ
プログラミング言語の総称である．
多くのオブジェクト指向言語が持つ概念としてクラスとメソッドが挙げられる．
クラスはオブジェクトの属性，メソッドはオブジェクトに対する操作である．
あるクラスを属性として持つオブジェクトをそのクラスのインスタンスと呼ぶ．
オブジェクトに対しメソッド名を指定してメソッド呼び出しを行うと，
オブジェクトのクラスに応じて適切なメソッドが選択され呼び出される．

このような言語においてはクラス名とメソッド名の2つが決まればメソッドが一意に定まる．
逆に言えば，あるクラスのインスタンスを操作するメソッドを定義する際には，
メソッドの内容の他にクラス名とメソッド名の2つを指定しなければならない．
これに対し一般に変数を定義する際には，変数の内容の他に変数名を指定する必要がある．

ここで1つのアイデアが考えれられる．
変数名の代わりに\textbf{クラス名とメソッド名の組}を用いることで，
変数と同じシンタックス，\textbf{かつ，同じセマンティクスで}
メソッドを定義できるのではないか．

本研究の目的は，変数とメソッドの定義を同じシンタックスかつ同じセマンティクスで行う
プログラミング言語Suzuを試作し，この方式の利点および欠点を調査することである．
Suzuは変数とメソッドを共に\textbf{レキシカル環境}に定義するため，
変数に対して行えるあらゆる操作がメソッドに対しても自然に行える．
具体的には，ローカル変数に対応する\textbf{ローカルメソッド}を定義できる，
関数の仮引数としてメソッドを受け取れる，
モジュールシステムによってメソッドの可視性を制御できるなどの特徴を持つ．

本稿は次のような構成をとる．
第\ref{chapter:background}章ではオブジェクト指向言語における変数定義および
メソッド定義の方式について述べる．
第\ref{chapter:implementation}章ではメソッドを変数と同様レキシカル環境に
定義するプログラミング言語Suzuの言語仕様を解説する．
第\ref{chapter:discussion}章では従来のオブジェクト指向言語の概念に対応する
Suzuのプログラム例やSuzu独自の特徴を生かしたプログラム例によって，
このメソッド定義方式の利点および欠点について考察する．
第\ref{chapter:related-work}章で関連研究について，
第\ref{chapter:future-work}章で今後の課題，
第\ref{chapter:conclusion}章で結論を述べる．


\chapter{変数定義とメソッド定義}
\label{chapter:background}

従来のオブジェクト指向言語における変数定義とメソッド定義の方式について分析し，
考案した新しいメソッド定義の方式について述べる．

\section{従来のオブジェクト指向言語}

クラスを持つオブジェクト指向言語においては，あるクラスのインスタンスを操作する
メソッドを定義する際，メソッドの内容の他にクラス名とメソッド名の2つを指定する
必要がある．
これに対し変数を定義するには，変数の内容の他に変数名を指定する必要がある．
例えばプログラミング言語Rubyでは，
\begin{quote}
\begin{verbatim}
class C
  def m
    ...
  end
end
\end{verbatim}
\end{quote}
のようにしてクラス\verb|C|のインスタンスを操作するメソッド\verb|m|を定義でき，
\begin{quote}
\begin{verbatim}
v = ...
\end{verbatim}
\end{quote}
のようにして変数\verb|v|を定義できる．同様にJavaでは
\begin{quote}
\begin{verbatim}
class C {
  int m(){
    ...
  }
}
\end{verbatim}
\end{quote}
のようにしてメソッドを定義し，
\begin{quote}
\begin{verbatim}
int v = ...
\end{verbatim}
\end{quote}
のようにして変数を定義する．型指定を必要とするかどうかの違いはあるものの，
どの言語においてもメソッドを定義するにはクラス名とメソッド名が必要で，
変数を定義するには変数名が必要である．

変数定義とメソッド定義はこのようにシンタックスが異なるだけでなく，
そのセマンティクスも大きく異なる．
RubyやJavaの場合メソッドはクラスに定義されるのに対し，
変数はプログラムのブロック構造に対応するレキシカル環境に定義される．
これによりプログラム内で局所的に有効なローカル変数を定義できる．

\section{考案したオブジェクト指向言語}

メソッド定義に必要なのはクラス名とメソッド名であり，変数定義に必要なのは変数名である．
では，変数名をクラス名とメソッド名の組に置き換えれば，
変数定義と同じシンタックス・同じセマンティクスでメソッドを定義できるのではないか．
例えばシンタックスとしては，メソッドは
\begin{quote}
\begin{verbatim}
let C#m = ...
\end{verbatim}
\end{quote}
のようにして定義し，変数は
\begin{quote}
\begin{verbatim}
let v = ...
\end{verbatim}
\end{quote}
のようにして定義する．\verb|C#m|はクラス名\verb|C|とメソッド名\verb|m|の組である．

またメソッド定義のセマンティクスも変数と同様にする．つまりメソッドをクラスではなく，
変数と同じレキシカル環境に定義する．
これはローカル変数に対応するローカルメソッドの定義を可能とする．
この方式の利点および欠点を調査するため，レキシカル環境にメソッドを定義する
オブジェクト指向言語Suzuを試作した．


\chapter{プログラミング言語Suzu}
\label{chapter:implementation}

変数とメソッドを共にレキシカル環境に定義するプログラミング言語Suzuの言語仕様を
コード例を交えて解説する．
コード例において式を省略する際は\verb|...|を用いる．

\section{基本的な要素}

変数は\verb|let|を用いて定義する．例えば変数\verb|v|を\verb|...|の値で
初期化して定義するには以下のようにする．
\begin{quote}
\begin{verbatim}
let v = ...
\end{verbatim}
\end{quote}

Suzuでは関数リテラルを記述できる．引数\verb|param1|，\verb|param2|を受け取って
\verb|...|を実行する関数は以下のように書ける．
\begin{quote}
\begin{verbatim}
^(param1, param2){ ... }
\end{verbatim}
\end{quote}

関数は\verb|def|を用いて定義できる．
\begin{quote}
\begin{verbatim}
def func(param1, param2):
  ...
end
\end{verbatim}
\end{quote}
これは以下のコードと等価である．
\begin{quote}
\begin{verbatim}
let func = ^(param1, param2){ ... }
\end{verbatim}
\end{quote}

関数\verb|func|を引数\verb|arg1|，\verb|arg2|で呼び出すには以下のようにする．
\begin{quote}
\begin{verbatim}
func(arg1, arg2)
\end{verbatim}
\end{quote}

最後の引数として関数リテラルを渡す際は専用の構文が使える．例えば
\begin{quote}
\begin{verbatim}
func(arg1, arg2, ^(param1, param2){ ... })
\end{verbatim}
\end{quote}
という関数呼び出しは
\begin{quote}
\begin{verbatim}
func(arg1, arg2)^(param1, param2):
  ...
end
\end{verbatim}
\end{quote}
と書ける．他の実引数や関数リテラルの仮引数，またはその両方がない場合，
\begin{quote}
\begin{verbatim}
func^(param1, param2):
  ...
end

func(arg1, arg2):
  ...
end

func:
  ...
end
\end{verbatim}
\end{quote}
のように省略して書ける．

Suzuでは\verb|:|からインデントの終わりまで（または\verb|{|から\verb|}|まで）を
ブロックと呼ぶ．
ブロック内のコードを実行する際は新たなレキシカル環境が生成され有効になり，
実行が終わると破棄される．
変数は有効なレキシカル環境に定義される．よってブロック内で定義された変数は
ブロック内でのみ参照可能なローカル変数となる．例えば
\begin{quote}
\begin{verbatim}
def begin(thunk):
  thunk()
end
\end{verbatim}
\end{quote}
のような関数\verb|begin|を用いて
\begin{quote}
\begin{verbatim}
begin:
  let v = ...
  ...
end
\end{verbatim}
\end{quote}
と書いた場合，変数\verb|v|は\verb|begin|から\verb|end|内のみで有効な
ローカル変数である．

\section{オブジェクトシステム}

Suzuでは変数名の代わりにクラス名とメソッド名の組を指定し，メソッドを変数と同様
レキシカル環境に定義する．
つまりメソッドを定義するには，
\begin{quote}
\begin{verbatim}
def C#m(self, param1, param2):
  ...
end
\end{verbatim}
\end{quote}
または
\begin{quote}
\begin{verbatim}
let C#m = ^(self, param1, param2){ ... }
\end{verbatim}
\end{quote}
のようにする．\verb|C|はクラス名，\verb|m|はメソッド名，\verb|C#m|は
クラス名とメソッド名の組である．

定義したメソッドは\verb|C#m|と書くことで変数のように参照できる他，
\verb|inst|をクラス\verb|C|のインスタンスとすると以下のようにして呼び出せる．
\begin{quote}
\begin{verbatim}
inst.m(arg1, arg2)
\end{verbatim}
\end{quote}
このとき\verb|self|には\verb|inst|，\verb|param1|には\verb|arg1|，
\verb|param2|には\verb|arg2|の内容がそれぞれ代入される．
つまりメソッドの第1引数にはメソッド呼び出しの対象となったオブジェクト自身が，
第2引数以降には実引数が渡される．

クラスは以下のようにして定義する．
\begin{quote}
\begin{verbatim}
class Point = make_point:
  x
  y
end
\end{verbatim}
\end{quote}
これにより，クラス\verb|Point|，コンストラクタ関数\verb|make_point|，
ゲッターメソッド\verb|Point#x|，\verb|Point#y|が定義される．
\verb|make_point|は\verb|x|と\verb|y|というフィールドを持った
\verb|Point|のインスタンスを生成する関数である．
フィールドへのアクセスは\verb|Point#x|，\verb|Point#y|を介してのみ行える．
例えば
\begin{quote}
\begin{verbatim}
let p = make_point(1, 2)
\end{verbatim}
\end{quote}
とすると，\verb|p.x|は\verb|1|，\verb|p.y|は\verb|2|となる．

クラス定義の際，
\begin{quote}
\begin{verbatim}
class Point = make_point:
  mutable x
  mutable y
end
\end{verbatim}
\end{quote}
のようにフィールド名の前に\verb|mutable|と書いた場合，上記に加えて
セッターメソッド\verb|Point#(x=)|，\verb|Point#(y=)|が定義される．
\begin{quote}
\begin{verbatim}
p.x = 3
p.y = 4
\end{verbatim}
\end{quote}
のような式は
\begin{quote}
\begin{verbatim}
p.(x=)(3)
p.(y=)(4)
\end{verbatim}
\end{quote}
というメソッド呼び出しに解釈されるため，これを用いて\verb|Point#(x=)|や
\verb|Point#(y=)|を呼び出すことで\verb|p|のフィールド\verb|x|，\verb|y|を
書き換えられる．

Suzuでは演算子の適用もメソッド呼び出しとして解釈される．
正規表現\verb$[-+*/%&|=<>]+$にマッチする文字列は演算子として扱われ，
優先順位や結合則は演算子の1文字目に依存する．
例えば
\begin{quote}
\begin{verbatim}
x <- y
\end{verbatim}
\end{quote}
という式は
\begin{quote}
\begin{verbatim}
x.(<-)(y)
\end{verbatim}
\end{quote}
と解釈される．優先順位や結合則は\verb|<|と同じである．

ここまで述べてきたことから分かるように，Suzuではクラス定義とメソッド定義を
分けて記述する．
つまりはクラスを定義した後に，そのクラスのインスタンスを操作するメソッドを
自由に追加できる．
また，メソッドは変数と同様レキシカル環境に定義されるため，特定のブロック内でのみ
有効なローカルメソッドを定義できる．
さらに演算子の適用もメソッド呼び出しとして解釈されるため，ローカルメソッドを
定義することでクラスごとの演算子の意味を局所的に変えることもできる．

\section{モジュールシステム}

Suzuはメソッドを変数と同様レキシカル環境に定義する．そのため可視性の制御も変数と同様
モジュールによって行う．

モジュールを定義するには以下のようにする．
\begin{quote}
\begin{verbatim}
module M:
  let f = ...
  let C#m = ...
  ...
  export f, C#m
end
\end{verbatim}
\end{quote}
これにより，変数\verb|f|とメソッド\verb|C#m|をエクスポートするモジュール
\verb|M|が定義される．
\verb|let|（または\verb|def|）を用いて変数やメソッドを定義した後，
\verb|export|の後にエクスポートしたい変数の変数名や，メソッドを表すクラス名と
メソッド名の組を並べて指定する．
エクスポートされている変数やメソッドは\verb|::|を用いて，
\verb|M::f|，\verb|M::(C#m)|のように参照できる．
モジュール内で定義した変数やメソッドをエクスポートしなかった場合，
それらはモジュール内でのみ有効なモジュールローカルな変数，またはメソッドとなる．

モジュールは任意のスコープで\verb|open|できる．例えば
\begin{quote}
\begin{verbatim}
begin:
  open M
  ...
end
\end{verbatim}
\end{quote}
とすると，\verb|begin|から\verb|end|までのブロックで\verb|M|から
エクスポートされている変数やメソッドを修飾子なしで参照できるようになる．
\verb|M|を先ほど定義したものとすると，\verb|f|，\verb|C#m|のように
変数やメソッドを参照可能となる．

既存のモジュールを活用して新しいモジュールを定義する際は
\verb|include|が便利である．
\begin{quote}
\begin{verbatim}
module B:
  include A
  ...
end
\end{verbatim}
\end{quote}
この例ではモジュール\verb|B|内でモジュール\verb|A|を\verb|include|している．
\verb|include A|とするとまず\verb|open A|が行われ，次に\verb|A|から
エクスポートされている
変数やメソッドをすべて\verb|B|からもエクスポートする．
これによりモジュール\verb|A|を拡張した新たなモジュール\verb|B|を容易に定義できる．

\verb|open|や\verb|include|によって新しく参照可能になる変数やメソッドが
衝突する場合，そのコードはエラーとなる．
例えば以下のコードは\verb|open Y|で\verb|C#q|が衝突するためエラーとなる．
\begin{quote}
\begin{verbatim}
module X:
  ... 
  export C#p, C#q
end
module Y:
  ...
  export C#q, C#r
end
begin:
  open X
  open Y
  ...
end
\end{verbatim}
\end{quote}
これを回避するには\verb|except|を用いる．
\begin{quote}
\begin{verbatim}
begin:
  open X except C#q
  open Y
  ...
end
\end{verbatim}
\end{quote}
この例では\verb|X|を\verb|open|する際\verb|C#q|を\verb|except|している．
これによりこの時点で\verb|C#q|はインポートされない．
よって\verb|open Y|としてもエラーは起きない．

Suzuにはパラメータ化されたモジュールとしてのトレイトという機構がある．
トレイトは値を受け取ってモジュールを返す関数である．
\begin{quote}
\begin{verbatim}
trait T(param1, param2):
  let f = ...
  let C#m = ...
  ...
  export f, C#m
end
\end{verbatim}
\end{quote}
この例では\verb|param1|と\verb|param2|を受け取って，\verb|f|と\verb|C#m|を
エクスポートするモジュールを返すトレイト\verb|T|を定義している．
トレイトの活用法については第\ref{chapter:discussion}章で述べる．


\chapter{プログラム例と考察}
\label{chapter:discussion}

従来のオブジェクト指向言語の概念に対応するSuzuのプログラム例や
Suzu独自の特徴を生かしたプログラム例によって，
レキシカル環境にメソッドを定義する方式の利点および欠点について考察する．

\section{多重継承}
superとか

\section{アクセス制限}
protectedはない

\section{モジュール分割}
Visitorパターン？

\section{ローカルメソッド}
Refinements

\chapter{関連研究}
\label{chapter:related-work}

特異メソッド，EQLスペシャライザ，プロトタイプベース

CLOS，多重ディスパッチ

Classbox，Method Shells

Haskellの型クラス

OCamlのユーザー定義演算子

Scalaのimplicit conversion

.NETの拡張メソッド

MixJuice


\chapter{今後の課題}
\label{chapter:future-work}

\section{ダイナミックスコープ}

\section{効率的な実装}


\chapter{結論}
\label{chapter:conclusion}


\chapter*{謝辞}
\addcontentsline{toc}{chapter}{\numberline{}謝辞}

本研究を行うにあたり，多大なるご指導とご助言を下さった筑波大学システム情報系
前田敦司准教授に深く感謝いたします．
また第56回プログラミング・シンポジウムにて有益なコメントを下さった方々に
感謝いたします．
最後に貴重なご意見を下さった筑波大学インタラクティブ・アーキテクチャ研究室の皆様と
OBの水島宏太さんに感謝いたします．

\newpage

%\addcontentsline{toc}{chapter}{\numberline{}参考文献}
\renewcommand{\bibname}{参考文献}

%% 参考文献に jbibtex を使う場合
\bibliographystyle{junsrt}
\bibliography{thesis}
%% [compile] jbibtex sample; platex sample; platex sample;

%% 参考文献を直接ファイルに含めて書く場合
%\begin{thebibliography}{1}
%\bibitem{RakRak}
%野寺隆志.
%\newblock 楽々 \LaTeX.
%\newblock 共立出版, 1990.
%
%\bibitem{JiyuuJizai}
%磯崎秀樹.
%\newblock \LaTeX 自由自在.
%\newblock サイエンス社, July 1992.
%
%\bibitem{bryant-ieeetc86}
%Randal~E. Bryant.
%\newblock Graph-based algorithms for {B}oolean function manipulation.
%\newblock {\em IEEE Transactions on Computers}, Vol. C-35, No.~8, pp. 677--691,
%  August 1986.
%\end{thebibliography}

\end{document}
