%%
% このファイルは、筑波大学情報学群情報科学類の
% 卒業研究論文本体のサンプルです。
% このファイルを書き換えて、この例と同じような書式の論文本体を
% LaTeXを使って作成することができます。
% 
% PC環境や、LaTeX環境の設定によっては漢字コードや改行コードを
% 変更する必要があります。
%%
\documentclass[a4paper,11pt,dvipdfmx]{jreport}

%%【PostScript, JPEG, PNG等の画像の貼り込み】
%% 利用するパッケージを選んでコメントアウトしてください。
\usepackage{graphicx} % for \includegraphics[width=3cm]{sample.eps}
%\usepackage{epsfig} % for \psfig{file=sample.eps,width=3cm}
%\usepackage{epsf} % for \epsfile{file=sample.eps,scale=0.6}
%\usepackage{epsbox} % for \epsfile{file=sample.eps,scale=0.6}

%% dvipdfm を使う場合(dvi->pdfを直接生成する場合)
%\usepackage[dvipdfm]{color,graphicx}
%% dvipdfm を使ってPDFの「しおり」を付ける場合
%\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,bookmarkstype=toc]{hyperref}
%% 参考：dvipdfm 日本語版
%% http://hamilcar.phys.kyushu-u.ac.jp/~hirata/dvipdfm/

\usepackage[bookmarksnumbered=true]{hyperref}
\usepackage{pxjahyper}

\usepackage{times} % use Times Font instead of Computer Modern

\setcounter{tocdepth}{3}
\setcounter{page}{-1}

\setlength{\oddsidemargin}{0.1in}
\setlength{\evensidemargin}{0.1in} 
\setlength{\topmargin}{0in}
\setlength{\textwidth}{6in} 
%\setlength{\textheight}{10.1in}
\setlength{\parskip}{0em}
\setlength{\topsep}{0em}

%\newcommand{\zu}[1]{{\gt \bf 図\ref{#1}}}

%% タイトル生成用パッケージ(重要)
\usepackage{coins-jp}
\usepackage{jumoline}

%% タイトル
%% 【注意】タイトルの最後に\\ を入れるとエラーになります
\title{\Underline{レキシカル環境にメソッドを定義する\\オブジェクト指向言語Suzu}}
%% 著者
\author{林 拓人}
%% 指導教員
\advisor{前田敦司}

%% 専攻名 と 年月 (提出年月)
%% 年月は必要に応じて書き替えてください。
\heiseiyear{26}  % 平成の年度
\majorfield{ソフトウェアサイエンス主専攻}
%\majorfield{情報システム主専攻}
%\majorfield{知能情報メディア主専攻}

\makeatletter%% プリアンブルで定義する場合は必須

%% (j)report・(j)book クラスの場合
%% 
\renewenvironment{thebibliography}[1]% 再定義
{\chapter*{\bibname\@mkboth{\bibname}{\bibname}}%
	\addcontentsline{toc}{chapter}{\numberline{}\bibname}% この行追加
	\list{\@biblabel{\@arabic\c@enumiv}}%
	{\settowidth\labelwidth{\@biblabel{#1}}%
		\leftmargin\labelwidth
		\advance\leftmargin\labelsep
		\@openbib@code
		\usecounter{enumiv}%
		\let\p@enumiv\@empty
		\renewcommand\theenumiv{\@arabic\c@enumiv}}%
	\sloppy
	\clubpenalty4000
	\@clubpenalty\clubpenalty
	\widowpenalty4000%
	\sfcode`\.\@m}
{\def\@noitemerr
	{\@latex@warning{Empty `thebibliography' environment}}%
	\endlist}

\makeatother%% プリアンブルで定義する場合は必須

\usepackage{listings}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage

\thispagestyle{empty}
\vspace*{20pt plus 1fil}
\parindent=1zw
\noindent
%%
%% 論文の概要(Abstract)
%%
\begin{center}
{\Large \bf 要　　旨}
\vspace{2cm}
\end{center}

オブジェクト指向言語においてメソッドを定義するにはクラス名とメソッド名が必要である．
これに対し変数を定義するには変数名が必要となる．
ここで変数名の代わりにクラス名とメソッド名の組を用いれば，
変数と同じシンタックスかつ同じセマンティクスでメソッドを定義できるのではないか．

このメソッド定義方式の有用性を検証するため，メソッドを変数のようにレキシカル環境に
定義するプログラミング言語Suzuを試作した．
Suzuはこのメソッド定義方式によりローカル変数に対応するローカルメソッドが定義でき，
組み込みオブジェクトに対しメソッドを局所的に追加・再定義できる，
演算子のユーザー定義と組み合わせてグローバル環境を汚染せず可読性の高い内部DSLを
作成できる，
クラスではなくモジュールによってメソッドをグループ化・再利用できるという特徴を持つ．

既存のオブジェクト指向言語における類似した概念との関連についても議論する．

%%%%%
\par
\vspace{0pt plus 1fil}
\newpage

\pagenumbering{roman} % I, II, III, IV 
\tableofcontents
%\listoffigures
%\listoftables

\pagebreak \setcounter{page}{1}
\pagenumbering{arabic} % 1,2,3


\chapter{序論}

オブジェクト指向言語とは，オブジェクト指向プログラミングの支援機構を持つ
プログラミング言語の総称である．
多くのオブジェクト指向言語が持つ概念としてクラスとメソッドが挙げられる．
クラスはオブジェクトの属性，メソッドはオブジェクトに対する操作である．
あるクラスを属性として持つオブジェクトをそのクラスのインスタンスと呼ぶ．
オブジェクトに対しメソッド名を指定してメソッド呼び出しを行うと，
オブジェクトのクラスに応じて適切なメソッドが選択され呼び出される．

このような言語においてはクラス名とメソッド名の2つが決まればメソッドが一意に定まる．
逆に言えば，あるクラスのインスタンスを操作するメソッドを定義する際には，
メソッドの内容の他にクラス名とメソッド名の2つを指定しなければならない．
これに対し一般に変数を定義する際には，変数の内容の他に変数名を指定する必要がある．

ここで1つのアイデアが考えれられる．
変数名の代わりに\textbf{クラス名とメソッド名の組}を用いることで，
変数と同じシンタックス，\textbf{かつ，同じセマンティクスで}
メソッドを定義できるのではないか．
これを採用するメリットとしては，ローカル変数に対応する\textbf{ローカルメソッド}を
定義できること，関数の仮引数として変数のみならずメソッドを指定できること，
メソッドの可視性の制御に変数と同じモジュールシステムを活用できることなどが
ある．

本研究の目的は，変数とメソッドの定義を同じシンタックスかつ同じセマンティクスで行う
プログラミング言語Suzuを試作し，その有用性を検証することである．
Suzuは特にユーザー定義演算子をローカルメソッドとして定義することで，
可読性の高い内部DSLを衝突のリスクを気にすることなく気軽に利用できるよう
設計されている．

本稿は次のような構成をとる．
第\ref{chapter:proposal}章ではオブジェクト指向言語における変数定義および
メソッド定義の方式について述べる．
第\ref{chapter:implementation}章では変数とメソッドを同等の仕組みで
定義するプログラミング言語Suzuの言語仕様を解説する．
第\ref{chapter:discussion}章ではSuzuのメソッド定義方式による特徴を生かした
プログラム例によってその有用性を検証する．
第\ref{chapter:related-work}章で関連研究について，
第\ref{chapter:future-work}章で今後の課題，
第\ref{chapter:conclusion}章で結論を述べる．


\chapter{提案手法}
\label{chapter:proposal}

従来のオブジェクト指向言語における変数定義とメソッド定義の方式について分析し，
考案した新しいメソッド定義の方式について述べる．

\section{従来のオブジェクト指向言語}

クラスベースのオブジェクト指向言語においては，あるクラスのインスタンスを操作する
メソッドを定義する際，メソッドの内容の他にクラス名とメソッド名の2つを必ず指定
しなければならない．

例えば，C++では
\begin{quote}
	\begin{verbatim}
	class C {
	public:
	  void m(){
	    ...
	  }
	};
	\end{verbatim}
\end{quote}
Javaでは
\begin{quote}
	\begin{verbatim}
	class C {
	  void m(){
	    ...
	  }
	}
	\end{verbatim}
\end{quote}
Rubyでは
\begin{quote}
	\begin{verbatim}
	class C
	  def m
	    ...
	  end
	end
	\end{verbatim}
\end{quote}
Pythonでは
\begin{quote}
	\begin{verbatim}
	class C:
	  def m(self):
	    ...
	\end{verbatim}
\end{quote}
のようにして，クラス\verb|C|のインスタンスを操作するメソッド\verb|m|を定義できる．

アクセス修飾子（\verb|public|）や戻り値の型（\verb|void|），
オブジェクト自身を指す仮引数（\verb|self|）など，言語によって追加で
指定しなければならない要素はあるものの，どの言語においてもメソッドを定義する際は
クラス名（\verb|C|）とメソッド名（\verb|m|）の2つが必須である．

これに対し変数を定義するには，変数の内容の他に変数名1つを必ず指定しなければ
ならない．
例えばC++やJavaでは
\begin{quote}
\begin{verbatim}
int v = ...
\end{verbatim}
\end{quote}
RubyやPythonでは
\begin{quote}
\begin{verbatim}
v = ...
\end{verbatim}
\end{quote}
のようにして変数\verb|v|を定義できる．
変数の型（\verb|int|）の指定の有無はあるものの，どの言語においても変数を
定義する際は変数名（\verb|v|）1つが必須である．

このように，変数定義とメソッド定義の間にあるシンタックス上の決定的な違いは，
変数を定義する際には変数名1つが必須なのに対し，メソッドを定義する際には
クラス名とメソッド名の2つが必須であるという点である．

変数定義とメソッド定義の間にはシンタックス上だけでなくセマンティクス上も
大きな違いが存在する．
それはスコープの違いである．
どの言語においても変数はブロックまたは関数・メソッド内でローカルな変数を
定義できる．
例えばC++やJavaでは
\begin{quote}
	\begin{verbatim}
	{
	  int v = ...
	  ...
	}
	\end{verbatim}
\end{quote}
とすればブロック\verb|{|～\verb|}|内でのみ有効な変数\verb|v|を定義できる．
Rubyでは
\begin{quote}
	\begin{verbatim}
	1.times do
	  v = ...
	  ...
	end
	\end{verbatim}
\end{quote}
とすればブロック\verb|do|～\verb|end|内でのみ有効な変数\verb|v|を定義でき，
\begin{quote}
	\begin{verbatim}
	def m
	  v = ...
	  ...
	end
	\end{verbatim}
\end{quote}
とすればメソッド\verb|m|内でのみ有効な変数\verb|v|を定義できる．
Pythonでは
\begin{quote}
	\begin{verbatim}
	def f():
	  v = ...
	  ...
	\end{verbatim}
\end{quote}
とすれば関数\verb|f|内でのみ有効な変数\verb|v|を定義できる．

このように変数のスコープが制限されるのは，変数がレキシカル環境に定義されるためである．
レキシカル環境とは，ブロックや関数・メソッドなどのプログラムの構造に対応して存在し，
変数名と変数の対応関係を保持するものである．
レキシカル環境の定義は対応する構造内のコードを実行中のみ参照できる．

これに対しメソッドは，例に挙げた言語ではクラスに所属させる形で定義するものであり，
どの言語においてもブロックや関数・メソッド内でローカルなメソッドを定義することはできない．
しかしながら，グローバル変数を多用するよりもローカル変数を適切に使用する方が
好ましいプログラミングスタイルであるように，ローカルメソッドを定義することができれば
それを用いた好ましいプログラミングスタイルが確立できるのではないかと考えられる．

\section{提案するオブジェクト指向言語}

そこで，本研究はローカル変数に対応するローカルメソッドが定義可能な
オブジェクト指向言語Suzuを試作し，その有用性を示す．

ローカルメソッドを実現する手法としては，変数定義とメソッド定義のシンタックスおよび
セマンティクスを統一するというアプローチをとる．
つまり，メソッドを変数と同じレキシカル環境に定義し，対応するブロック内でのみ
参照可能にする．

変数を定義する際には変数名1つが必須なのに対し，メソッドを定義する際には
クラス名とメソッド名の2つが必須であるということは先ほど述べた．
逆にいえば，変数は最低でも変数名1つによって識別される概念なのに対し，
メソッドは最低でもクラス名とメソッド名の2つによって識別される概念だということである．
ここで，クラス名とメソッド名を組にして1つの名前としてとらえれば，
メソッドはクラス名とメソッド名の組1つによって識別される概念となる．
つまり変数名を指定すべき箇所にクラス名とメソッド名の組を指定すれば，
変数定義とメソッド定義のシンタックスを統一できる．
例えば，
\begin{quote}
	\begin{verbatim}
	let v = ...
	\end{verbatim}
\end{quote}
のようにして変数を定義し，
\begin{quote}
	\begin{verbatim}
	let C#m = ...
	\end{verbatim}
\end{quote}
のようにしてメソッドを定義する．\verb|C#m|はクラス名\verb|C|とメソッド名\verb|m|の
組である．
また，変数名と変数の対応関係を保持するレキシカル環境に
クラス名とメソッド名の組とメソッドの対応関係を保持させることで
セマンティクスも統一できる．
これにより，\verb|begin|～\verb|end|をブロックとすると，
\begin{quote}
	\begin{verbatim}
	begin:
	  let v = ...
	  ...
	end
	\end{verbatim}
\end{quote}
のようにしてブロックローカルな変数を定義でき，
\begin{quote}
	\begin{verbatim}
	begin:
	  let C#m = ...
	  ...
	end
	\end{verbatim}
\end{quote}
のようにしてブロックローカルなメソッドを定義できる．


\chapter{プログラミング言語Suzu}
\label{chapter:implementation}

レキシカル環境にメソッドを定義するプログラミング言語Suzuの言語仕様を
コード例を交えて解説する．
コード例において式を省略する際は\verb|...|を用いる．

\section{基本的な要素}

変数は\verb|let|を用いて定義する．例えば変数\verb|v|を\verb|...|の値で
初期化して定義するには以下のようにする．
\begin{quote}
\begin{verbatim}
let v = ...
\end{verbatim}
\end{quote}

Suzuでは関数リテラルを記述できる．引数\verb|param1|，\verb|param2|を受け取って
\verb|...|を実行する関数は以下のように書ける．
\begin{quote}
\begin{verbatim}
^(param1, param2){ ... }
\end{verbatim}
\end{quote}

関数は\verb|def|を用いて定義できる．
\begin{quote}
\begin{verbatim}
def func(param1, param2):
  ...
end
\end{verbatim}
\end{quote}
これは以下のコードと等価である．
\begin{quote}
\begin{verbatim}
let func = ^(param1, param2){ ... }
\end{verbatim}
\end{quote}

関数\verb|func|を引数\verb|arg1|，\verb|arg2|で呼び出すには以下のようにする．
\begin{quote}
\begin{verbatim}
func(arg1, arg2)
\end{verbatim}
\end{quote}

最後の引数として関数リテラルを渡す際は専用の構文が使える．例えば
\begin{quote}
\begin{verbatim}
func(arg1, arg2, ^(param1, param2){ ... })
\end{verbatim}
\end{quote}
という関数呼び出しは
\begin{quote}
\begin{verbatim}
func(arg1, arg2)^(param1, param2):
  ...
end
\end{verbatim}
\end{quote}
と書ける．他の実引数や関数リテラルの仮引数，またはその両方がない場合，
\begin{quote}
\begin{verbatim}
func^(param1, param2):
  ...
end

func(arg1, arg2):
  ...
end

func:
  ...
end
\end{verbatim}
\end{quote}
のように省略して書ける．

Suzuでは\verb|:|からインデントの終わりまで（または\verb|{|から\verb|}|まで）を
ブロックと呼ぶ．
ブロック内のコードを実行する際は新たなレキシカル環境が生成され有効になり，
実行が終わると破棄される．
変数は有効なレキシカル環境に定義される．よってブロック内で定義された変数は
ブロック内でのみ参照可能なローカル変数となる．例えば
\begin{quote}
\begin{verbatim}
def begin(thunk):
  thunk()
end
\end{verbatim}
\end{quote}
のような無引数の関数\verb|thunk|を受け取って呼び出す高階関数
\verb|begin|に
\begin{quote}
\begin{verbatim}
begin:
  let v = ...
  ...
end
\end{verbatim}
\end{quote}
のように無引数の関数リテラルを渡して呼び出させた場合，変数\verb|v|は
\verb|begin|から\verb|end|の間のみで有効なローカル変数となる．

\section{オブジェクトシステム}

Suzuでは変数名の代わりにクラス名とメソッド名の組を指定し，メソッドを変数と同様
レキシカル環境に定義する．
つまりメソッドを定義するには，
\begin{quote}
\begin{verbatim}
def C#m(self, param1, param2):
  ...
end
\end{verbatim}
\end{quote}
または
\begin{quote}
\begin{verbatim}
let C#m = ^(self, param1, param2){ ... }
\end{verbatim}
\end{quote}
のようにする．\verb|C|はクラス名，\verb|m|はメソッド名，\verb|C#m|は
クラス名とメソッド名の組である．

定義したメソッドは\verb|C#m|と書くことで変数のように参照できる他，
\verb|inst|をクラス\verb|C|のインスタンスとすると以下のようにして呼び出せる．
\begin{quote}
\begin{verbatim}
inst.m(arg1, arg2)
\end{verbatim}
\end{quote}
これは以下の呼び出しと同じ結果となる．
\begin{quote}
\begin{verbatim}
C#m(inst, arg1, arg2)
\end{verbatim}
\end{quote}
このように，メソッドの第1引数にはメソッド呼び出しの対象となったオブジェクト自身が，
第2引数以降には実引数が渡される．
つまり\verb|self|には\verb|inst|，\verb|param1|には\verb|arg1|，
\verb|param2|には\verb|arg2|の内容がそれぞれ代入される．

クラスは以下のようにして定義する．
\begin{quote}
\begin{verbatim}
class Point = make_point:
  x
  y
end
\end{verbatim}
\end{quote}
これにより，クラス\verb|Point|，コンストラクタ関数\verb|make_point|，
ゲッターメソッド\verb|Point#x|，\verb|Point#y|が定義される．
\verb|make_point|は\verb|x|と\verb|y|というフィールドを持った
\verb|Point|のインスタンスを生成する関数である．
フィールドへのアクセスは\verb|Point#x|，\verb|Point#y|を介してのみ行える．
例えば
\begin{quote}
\begin{verbatim}
let p = make_point(1, 2)
\end{verbatim}
\end{quote}
とすると，\verb|p.x|は\verb|1|，\verb|p.y|は\verb|2|となる．

クラス定義の際，
\begin{quote}
\begin{verbatim}
class Point = make_point:
  mutable x
  mutable y
end
\end{verbatim}
\end{quote}
のようにフィールド名の前に\verb|mutable|と書くと，上記に加えて
セッターメソッド\verb|Point#(x=)|，\verb|Point#(y=)|が定義される．
\begin{quote}
\begin{verbatim}
p.x = 3
p.y = 4
\end{verbatim}
\end{quote}
のような式は
\begin{quote}
\begin{verbatim}
p.(x=)(3)
p.(y=)(4)
\end{verbatim}
\end{quote}
というメソッド呼び出しに解釈されるため，これを用いて\verb|Point#(x=)|や
\verb|Point#(y=)|を呼び出すことで\verb|p|のフィールド\verb|x|，\verb|y|を
書き換えられる．

Suzuでは演算子の適用もメソッド呼び出しとして解釈される．
正規表現\verb$[-+*/%&|=<>]+$にマッチする文字列は演算子として扱われ，
優先順位や結合則は演算子の1文字目に依存する．
例えば
\begin{quote}
\begin{verbatim}
x <- y
\end{verbatim}
\end{quote}
という式は
\begin{quote}
\begin{verbatim}
x.(<-)(y)
\end{verbatim}
\end{quote}
と解釈される．優先順位や結合則は\verb|<|と同じである．

ここまで述べてきたことから分かるように，Suzuではクラス定義とメソッド定義を
分けて記述する．
つまりはクラスを定義した後に，そのクラスのインスタンスを操作するメソッドを
自由に追加できる．
また，メソッドは変数と同様レキシカル環境に定義されるため，特定のブロック内でのみ
有効なローカルメソッドを定義できる．
さらに演算子の適用もメソッド呼び出しとして解釈されるため，ローカルメソッドを
定義することでクラスごとの演算子の意味を局所的に変えることもできる．

\section{モジュールシステム}

モジュールシステムとは，変数やメソッドのエクスポート・インポートを制御し，抽象化や
再利用を促進する機構である．
Suzuはメソッドを変数と同様レキシカル環境に定義するため，可視性の制御も変数と同様
モジュールによって行う．

モジュールを定義するには以下のようにする．
\begin{quote}
\begin{verbatim}
module M:
  let f = ...
  let C#m = ...
  ...
  export f, C#m
end
\end{verbatim}
\end{quote}
これにより，変数\verb|f|とメソッド\verb|C#m|をエクスポートするモジュール
\verb|M|が定義される．
\verb|let|（または\verb|def|）を用いて変数やメソッドを定義した後，
\verb|export|の後にエクスポートしたい変数の変数名や，メソッドを表すクラス名と
メソッド名の組を並べて指定する．
エクスポートされている変数やメソッドは\verb|::|を用いて，
\verb|M::f|，\verb|M::(C#m)|のように参照できる．
モジュール内で定義した変数やメソッドをエクスポートしなかった場合，
それらはモジュール内でのみ有効なモジュールローカルな変数，またはメソッドとなる．

モジュールは任意のスコープで\verb|open|できる．例えば
\begin{quote}
\begin{verbatim}
begin:
  open M
  ...
end
\end{verbatim}
\end{quote}
とすると，\verb|begin|から\verb|end|までのブロックで\verb|M|から
エクスポートされている変数やメソッドを修飾子なしで参照できるようになる．
\verb|M|を先ほど定義したものとすると，\verb|f|，\verb|C#m|のように
変数やメソッドを参照可能となる．

既存のモジュールを活用して新しいモジュールを定義する際は
\verb|include|が便利である．
\begin{quote}
\begin{verbatim}
module B:
  include A
  ...
end
\end{verbatim}
\end{quote}
この例ではモジュール\verb|B|内でモジュール\verb|A|を\verb|include|している．
\verb|include A|とするとまず\verb|open A|が行われ，次に\verb|A|から
エクスポートされている
変数やメソッドをすべて\verb|B|からもエクスポートする．
これによりモジュール\verb|A|を拡張した新たなモジュール\verb|B|を容易に定義できる．

\verb|open|や\verb|include|によって新しく参照可能になる変数やメソッドが
衝突する場合，そのコードはエラーとなる．
例えば以下のコードは\verb|open Y|で\verb|C#q|が衝突するためエラーとなる．
\begin{quote}
\begin{verbatim}
module X:
  ... 
  export C#p, C#q
end
module Y:
  ...
  export C#q, C#r
end
begin:
  open X
  open Y
  ...
end
\end{verbatim}
\end{quote}
これを回避するには\verb|except|を用いる．
\begin{quote}
\begin{verbatim}
begin:
  open X except C#q
  open Y
  ...
end
\end{verbatim}
\end{quote}
この例では\verb|X|を\verb|open|する際\verb|C#q|を\verb|except|している．
これによりこの時点で\verb|C#q|はインポートされない．
よって\verb|open Y|としても衝突は起こらずエラーは回避される．

Suzuにはパラメータ化されたモジュールとしてのトレイトという機構がある．
トレイトは値を受け取ってモジュールを返す関数である．
\begin{quote}
\begin{verbatim}
trait T(param1, param2):
  let f = ...
  let C#m = ...
  ...
  export f, C#m
end
\end{verbatim}
\end{quote}
この例では\verb|param1|と\verb|param2|を受け取って，\verb|f|と\verb|C#m|を
エクスポートするモジュールを返すトレイト\verb|T|を定義している．
トレイトの活用法については第\ref{chapter:discussion}章で述べる．


\chapter{考察}
\label{chapter:discussion}

Suzuのローカルメソッドやモジュールシステムを生かしたプログラム例によって，
レキシカル環境にメソッドを定義することの有用性について検証する．
なお，\verb|p|は引数として受け取った値を出力する関数，
\verb|//|から行末まではコメントである．
ここではコメントとして\verb|//=>|の後にプログラムの出力内容を記述する．

\section{組み込みオブジェクトに対するメソッドの追加}

Suzuではメソッド定義がクラス定義から独立しているため，組み込みオブジェクトに
対するメソッドもユーザーが自由に追加できる．例えば，
\begin{quote}
\begin{verbatim}
p("program".pluralize)    //=> "programs"
p("programs".singularize) //=> "program"
p("person".pluralize)     //=> "people"
p("people".singularize)   //=> "person"
\end{verbatim}
\end{quote}
のように，文字列を複数形および単数形に変換するメソッド
\verb|pluralize|，\verb|singularize|が欲しいと思えば，
\begin{quote}
\begin{verbatim}
def String::C#pluralize(self):
  ...
end
def String::C#singularize(self):
  ...
end
\end{verbatim}
\end{quote}
のようにして定義できる．
\verb|String::C|というのはモジュール\verb|String|の変数\verb|C|で，
組み込みオブジェクトである文字列のクラス名を指している．

定義をブロック内で行えばこれらはローカルメソッドとなるため，メソッドの衝突を
未然に防ぐことができる．
\begin{quote}
\begin{verbatim}
begin:
  def String::C#pluralize(self):
    ...
  end
  def String::C#singularize(self):
    ...
  end
  ...
end
\end{verbatim}
\end{quote}
上の例では2つのメソッド定義は\verb|begin|から\verb|end|の間でのみ
有効である．

また，複数のメソッドをまとめてモジュールとして提供することもできる．
\begin{quote}
\begin{verbatim}
module Noun:
  def String::C#pluralize(self):
    ...
  end
  def String::C#singularize(self):
    ...
  end
  ...
  export String::C#pluralize, String::C#singularize
end
\end{verbatim}
\end{quote}
これをブロック内で\verb|open|すれば直接定義したのと同じ効果が得られる．
\begin{quote}
\begin{verbatim}
begin:
  open Noun
  ...
end
\end{verbatim}
\end{quote}
このように，利便性の高いメソッド群をユーザーがモジュールとして提供し，
局所的に有効にすることでメソッド衝突の危険を避けながら利用できる．


\section{メソッドの柔軟なグループ化}

Suzuのメソッド定義はクラス定義とは独立しており，モジュールに所属する形で
定義することができる．
そのため対象のクラスによらず関連性の高いメソッドを集めて柔軟にグループ化できる．

例えばオブジェクトをJSON形式でシリアライズするメソッド\verb|to_json|を
定義したい場合，クラスにメソッドを定義する言語では定義が各クラスに分散して
しまう．

Suzuでは以下のように複数のクラスのインスタンスに対するメソッドを提供する
モジュールを定義することで，関連するメソッドを1箇所にまとめて定義できる．
\begin{quote}
\begin{verbatim}
module ToJSON:
  let    Int::C#to_json = ...
  let String::C#to_json = ...
  let   List::C#to_json = ...
  ...
end
\end{verbatim}
\end{quote}
利用する側は有効にしたいスコープで\verb|open ToJSON|とすればよい．

また，ユーザーが新たに定義したデータ型などさらに多くのオブジェクトにメソッドを
提供したい場合，
\begin{quote}
\begin{verbatim}
module ToJSONExt:
  include ToJSON
  let UserDefinedData1#to_json = ...
  let UserDefinedData2#to_json = ..
  ...
end
\end{verbatim}
\end{quote}
のように\verb|include|を用いて，既存のモジュールを拡張した
新たなモジュールを定義できる．


\section{演算子の局所的な再定義}

Suzuでは演算子の適用がメソッド呼び出しとして扱われる．そのため演算子に対応する
メソッドを局所的に再定義することで，その振る舞いを変えることができる．

例えば整数同士の割り算を行うメソッド\verb|Int::C#(/)|は，組み込みのものは
整数を返す．
これを浮動小数点数を返す関数\verb|Int::quo|で置き換えたい場合，
単に\verb|let|を用いればよい．
\begin{quote}
\begin{verbatim}
p(3 / 2) //=> 1
begin:
  let Int::C#(/) = Int::quo
  p(3 / 2) //=> 1.5
end
p(3 / 2) //=> 1
\end{verbatim}
\end{quote}

また以下のようなモジュール\verb|Quotient|を定義しておけば，
ブロック内で\verb|open|することでそのスコープでのみ浮動小数点数を
返すよう変えることができる.
\begin{quote}
\begin{verbatim}
module Quotient:
  let Int::C#(/) = Int::quo
  export Int::C#(/)
end

p(3 / 2) //=> 1
begin:
  open Quotient
  p(3 / 2) //=> 1.5
end
p(3 / 2) //=> 1
\end{verbatim}
\end{quote}

Suzuのメソッドはレキシカルスコープなので，ブロック内から呼び出した先の関数に
影響を与えることなく安全に演算子の再定義ができる．


\section{内部DSL}

DSLとはDomain Specific Languageの略で，特定の問題を解決するのに特化した
ミニ言語のことである．
特に内部DSLとは，プログラム内に記述できる式として構築したDSLを指す．

Suzuは演算子として使用できる文字列に自由度があるため，
演算子をローカルメソッドとして定義すれば，グローバル環境を汚染せず可読性の高い
内部DSLを作成できる．
以下の例は演算子式によって正規表現を構築できるDSLを提供するモジュール
\verb|PrettyRegex|を定義している．\verb|String::format|は
文字列整形関数である．
\begin{quote}
\begin{verbatim}
module PrettyRegex:
  def String::C#(|)(lhs, rhs):
    String::format("({0}|{1})", lhs, rhs)
  end
  def String::C#(+)(lhs, rhs):
    String::format("{0}{1}", lhs, rhs)
  end
  def Char::C#(-)(lhs, rhs):
    String::format("[{0}-{1}]", lhs, rhs)
  end
  def String::C#one_or_more(exp):
    String::format("{0}+", exp)
  end
  export String::C#(|)
  export String::C#(+)
  export String::C#one_or_more
  export Char::C#(-)
end
\end{verbatim}
\end{quote}
これは以下のように使用できる．
\begin{quote}
\begin{verbatim}
let regex = begin:
  open PrettyRegex
  ("foo"|"bar")+('0'-'9').one_or_more
end
p(regex) //=> "(foo|bar)[0-9]+"
\end{verbatim}
\end{quote}
縦棒やプラス，ハイフンといった衝突の危険が高いと思われる短い演算子も，
スコープを限定して定義することで安心して使用できる．


\section{パラメータ化されたモジュール}

Suzuにはパラメータ化されたモジュールとしてのトレイトという機能がある．
トレイトを使うと，対象のクラスと必要なメソッドを与えることで
複数のメソッドを提供するモジュールを返す関数を書くことができる．

例えばトレイト\verb|Enumerable|はクラス\verb|C|とメソッド
\verb|C#each|を与えて戻り値を\verb|open|することで，
\begin{quote}
\begin{verbatim}
trait Enumerable(C, C#each):
  let C#map = ...
  let C#count = ...
  let C#find = ...
  let C#reduce = ...
  ...
end
\end{verbatim}
\end{quote}
これは，\verb|C#balance|が定義されている任意のクラス\verb|C|に
\verb|C#deposit!|および\verb|C#withdraw!|を提供する関数であると言える．


\section{多重継承の代替}

トレイトは多重継承の代替機構としても利用できる.
以下の例ではメソッド\verb|read|を定義するトレイト\verb|Readable|と
\verb|write|を定義する\verb|Writable|をクラス\verb|ReadWriteStream|
に対して呼び出し\verb|open|することで，\verb|read|と\verb|write|の
両方のメソッドを提供している．
\begin{quote}
\begin{verbatim}
trait Readable(C, ...):
  let C#read = ...
  ...
end

trait Writable(C, ...):
  let C#write = ...
  ...
end

open Readable(ReadWriteStream, ...)
open Writable(ReadWriteStream, ...)
\end{verbatim}
\end{quote}
もしメソッドの衝突が起きるようならばエラーが起きるため，
\verb|except|を使って適切に回避する必要がある．

このように，Suzuはメソッドをクラスではなくレキシカル環境に定義するため，
モジュールシステムによってメソッドを整理・再利用・局所的に有効化することが
できる．


\chapter{関連研究}
\label{chapter:related-work}

Suzuのメソッド定義方式がもたらす柔軟性に類似した性質を持つ既存の概念について
述べる．

GluonJ\cite{GluonJ}はアスペクト指向プログラミングを支援するJavaの拡張である．
Glueと呼ばれるクラスを定義することで，既存のクラスに対しメソッドを追加・再定義する
などの拡張が可能である．
しかし拡張の影響はグローバルで範囲を限定することはできない．

C\#の拡張メソッド\cite{ExtentionMethods}は既存のクラスにメソッドを
追加したように見せることができる．
実際に呼ばれるのは第1引数に\verb|this|と指定した静的メソッドである．
拡張メソッドは\verb|using|ディレクティブによって有効無効を制御できるが，
同じシグネチャを持つ拡張メソッドが複数存在する場合エラーが起き，
これを回避する仕組みを持たない．
また既に通常の方法で定義されているメソッドを再定義することもできない．

Scala\cite{Scala}のimplicit conversionも既存のクラスに対しメソッドを
追加したように見せる機能である．
実際は存在しないメソッドが呼ばれた際に型変換を行うことで，別のクラスのメソッドを
呼び出している．
スコープはブロック単位で制御できるが，同じシグネチャのメソッドを提供する
型への変換が複数存在する場合エラーが起き，これを回避する仕組みを持たない．
またこれも拡張メソッドと同様，既に通常の方法で定義されているメソッドを
再定義することはできない．

Haskellの型クラス\cite{TypeClasses}はオブジェクト指向プログラミングのための
機構ではないが，
データ型の定義と独立して型ごとに操作を定義できる点がSuzuのメソッドに類似している．
型クラスは導入に静的な型を必要とするが，Suzuのメソッドはこれを必要としない．
また型クラスにおいて操作の実体を定義するインスタンス宣言は
モジュールシステムによって個別にエクスポートするかどうかの指定ができない．
ただし型クラスは戻り値の型に応じて関数の振る舞いを変えさせることができるのに対し，
Suzuではこれは不可能である．

OCaml\cite{OCaml}のlocal openはSuzuと同様モジュール内の変数を局所的に
インポートできる．
これとユーザー定義演算子を組み合わせると演算子の意味を局所的に変えられる．
しかしOCamlにはオーバーロードが無いため演算子の振る舞いを型ごとに
変えることができず，既存の演算子を上書きしてしまうため内部DSLを構築するには
不便である．

Traits\cite{Traits,ApplyingTraits}はSuzuのトレイトの元となった概念である．
メソッドの集合であるトレイトに対し合成やリネームなどの演算を行うことで，
メソッドの衝突を回避しつつクラスにメソッドを提供できる．
Suzuはクラスではなくレキシカル環境にメソッドを定義するため，
トレイトを値を受け取ってモジュールを返す関数としてとらえ直した．
この方式では必要なメソッドと提供するメソッドが関数の引数と戻り値として明確となり，
モジュール演算によってメソッドの衝突を回避できることを示した．

CLOS\cite{CLOS}はCommon Lispの言語仕様に含まれるオブジェクト指向
プログラミングの支援機構で，メソッドをクラスとは独立して定義する．
メソッドはクラスではなく総称関数に対して追加され，総称関数は引数として
与えられたオブジェクトに応じて適切なメソッドを選択し呼び出す．
CLOSはCLtL2\cite{CLtL2}と呼ばれる仕様では既存の総称関数の内容を
コピーしてローカルな総称関数を定義する\verb|with-added-methods|が
含まれていたが，最新の仕様からは削除されている．
これはメソッドのローカル定義が有用でないと判断されたためだが，
Suzuは非S式文法の言語におけるユーザー定義演算子との組み合わせによって
ローカルメソッドの有効な利用法を示した．

Classbox\cite{Classboxes}，Refinements\cite{Refinements}，
Method Shells\cite{MethodShells}は，いずれも既存の
オブジェクト指向言語に対しモジュール単位でスコープを限定したメソッドの
追加・再定義を行うための機構である．
違いはメソッドのスコープルールであり，Classboxはダイナミックスコープ，
Refinementsはレキシカルスコープ，Method Shellsはそれらを切り替えられる．
SuzuのモジュールシステムはRefinementsに近い．ただしSuzuは
モジュール単位のみならずブロック単位でメソッドの追加・再定義が行え，
内部DSLの構築の際により利便性が高い．

MixJuice\cite{MixJuice}はクラス定義を複数のモジュールに分割して
書くことができる言語である．
MixJuiceによるモジュール分割はSuzuが行えるそれと非常に類似している．
MixJuiceにはパラメータ化されたモジュールがないがSuzuにはある，
Suzuには静的な型検査がないがMixJuiceにはあるという違いがある．


\chapter{今後の課題}
\label{chapter:future-work}

\section{多重ディスパッチ}

1つのオブジェクトのクラスに応じてメソッドの選択を行う単一ディスパッチに対し，
複数のオブジェクトのクラスに応じてメソッドの選択を行うのが多重ディスパッチである．
Suzuは単一ディスパッチにしか対応していないが，メソッドはクラスではなく
レキシカル環境に定義されているためディスパッチで考慮するクラスを
1つに限定する必要はなく，多重ディスパッチが可能なCLOSに倣えば原理上は比較的容易に
多重ディスパッチに対応できると考えられる．

問題は適切なシンタックスを考案することである．内部DSLの構築にあたっては
語順も重要な要素なので，なるべく語順を崩すことのない文法が必要である．

\section{ダイナミックスコープ}

Suzuのメソッドは変数と同じレキシカルスコープである．
これにより演算子を用いた内部DSLを構築する際，外部の関数呼び出し時に
演算子の振る舞いが変わっているために破綻してしまうようなことが起きない
ようになっている．

しかしながらダイナミックスコープであるほうが有用な場合もある．
例えば値を出力する関数\verb|print|が内部で値に対しメソッド\verb|to_string|
を呼び出しているとすると，ダイナミック環境の\verb|to_string|を再定義することで
局所的に出力内容を変えることができる．

レキシカル・ダイナミック共に有用であるため，ユースケースを分析し
適切な方法で共存させつつ導入する必要がある．

\section{オブジェクト固有のメソッド}

Rubyの特異メソッド，Common LispのEQLスペシャライザ，あるいはECMAScript
\cite{ECMAScript}のようなプロトタイプベースのオブジェクト指向言語を用いると，
オブジェクトに対しクラスによらない固有のメソッドを定義できる．
Suzuは現状そのような仕組みは持っておらず，オブジェクト固有のメソッドは定義できない．
しかしながらまずはこれら既存の仕組みの有用性自体を検証する必要がある．

\section{効率的な実装}

Suzuではブロックという細かい単位でメソッドの再定義ができる．
これはつまり同じメソッド呼び出しでもプログラムのどの位置に書かれたかによって
呼び出されるメソッドが変化するということであり，
キャッシュを効かせにくいという欠点がある．
現在Suzuの処理系はメソッド呼び出しに関して特に最適化を施しておらず，
適切な最適化手法を考え実装することが課題である．

\section{オブジェクトのmix}

\chapter{結論}
\label{chapter:conclusion}

メソッドを変数と同様レキシカル環境に定義するオブジェクト指向言語Suzuを試作した．
変数名の代わりにクラス名とメソッド名の組を用いることで，
変数とメソッドを同じシンタックス，かつ，同じセマンティクスで定義できる．
これによりローカル変数に対応するローカルメソッドが定義したり，
クラスではなくモジュールによってメソッドの可視性を制御したり，
メソッドによってパラメータ化されたモジュールを定義したりすることができる．

これらの特徴は実際のプログラミングにおいて有用である．
組み込みオブジェクトに対するメソッドの追加または再定義したり，
ローカルメソッドをユーザー定義演算子と組み合わせてグローバル環境を汚染しない
可読性の高い内部DSLを構築したり，
クラスごとにまとめるのではなくモジュールによって関連性の高いメソッドを1箇所に
まとめて定義したり，
パラメータ化さたモジュールによって衝突回避を行いながら多重継承に相当する
モジュールの再利用ができたりといった具体例を挙げた

従来の研究と比べメソッドのスコープをブロックという細かい単位で制限でき，
かつ衝突回避のための機構を持つことがSuzuの優れている点である．

今後は他のオブジェクト指向言語が持つ機能への対応や効率的な実装が課題である．


\chapter*{謝辞}
\addcontentsline{toc}{chapter}{\numberline{}謝辞}

本研究を行うにあたり，多大なるご指導とご助言を下さった筑波大学システム情報系
前田敦司准教授に深く感謝いたします．
また第56回プログラミング・シンポジウムにて有益なコメントを下さった方々に
感謝いたします．
最後に貴重なご意見を下さった筑波大学インタラクティブ・アーキテクチャ研究室の皆様と
OBの水島宏太さんに感謝いたします．

\newpage

\nocite{ContextJ}
\nocite{C3Linearization}
\nocite{CISCO}
\nocite{OptimizingMessageSends}
\nocite{MethodCachingForRuby}
\nocite{ShiftResetTutorial}
\nocite{ShiftResetOnMinCaml}
\nocite{ExnAndDelimCont}
%\addcontentsline{toc}{chapter}{\numberline{}参考文献}
\renewcommand{\bibname}{参考文献}

%% 参考文献に jbibtex を使う場合
\bibliographystyle{junsrt}
\bibliography{thesis}
%% [compile] jbibtex sample; platex sample; platex sample;

%% 参考文献を直接ファイルに含めて書く場合
%\begin{thebibliography}{1}
%\bibitem{RakRak}
%野寺隆志.
%\newblock 楽々 \LaTeX.
%\newblock 共立出版, 1990.
%
%\bibitem{JiyuuJizai}
%磯崎秀樹.
%\newblock \LaTeX 自由自在.
%\newblock サイエンス社, July 1992.
%
%\bibitem{bryant-ieeetc86}
%Randal~E. Bryant.
%\newblock Graph-based algorithms for {B}oolean function manipulation.
%\newblock {\em IEEE Transactions on Computers}, Vol. C-35, No.~8, pp. 677--691,
%  August 1986.
%\end{thebibliography}

\end{document}
